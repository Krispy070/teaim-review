Absolute unit, Kris. Secrets are in, last push is stable—so here’s Next Big Build in one shot:

Artifacts Tags & Filters (organize + filter docs fast)

CSV Export for Actions / Risks / Decisions (ops-ready reporting)

Impersonate (dev-only) switcher (preview any role without logging out)

Actions Kanban (Todo → In-Progress → Done, drag & drop)

All patches are paste-ready. If any paths differ, ping me and I’ll refit 1:1.

0) SQL — tags + policies (run in Supabase SQL)
-- Tags & mapping
create table if not exists public.tags (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null,
  name text not null,
  created_at timestamptz not null default now(),
  unique (org_id, name)
);

create table if not exists public.artifact_tags (
  org_id uuid not null,
  project_id uuid not null,
  artifact_id uuid not null,
  tag_id uuid not null,
  created_at timestamptz not null default now(),
  primary key (org_id, project_id, artifact_id, tag_id)
);

-- RLS
alter table public.tags enable row level security;
alter table public.artifact_tags enable row level security;

create policy "tags_read_same_org" on public.tags
for select using (org_id = public.current_org());

create policy "tags_write_pmplus" on public.tags
for insert with check (org_id = public.current_org() and public.has_role(org_id, null, array['owner','admin','pm','lead']));

create policy "at_select_member" on public.artifact_tags
for select using (org_id = public.current_org() and public.is_member(org_id, project_id));

create policy "at_insert_pmplus" on public.artifact_tags
for insert with check (org_id = public.current_org() and public.is_member(org_id, project_id)
  and public.has_role(org_id, project_id, array['owner','admin','pm','lead']));

create policy "at_delete_pmplus" on public.artifact_tags
for delete using (org_id = public.current_org() and public.is_member(org_id, project_id)
  and public.has_role(org_id, project_id, array['owner','admin','pm','lead']));

select pg_notify('pgrst','reload schema');

1) Backend
1A) Artifact Tags API

server/routers/artifact_tags.py

from fastapi import APIRouter, Depends, Query, HTTPException
from pydantic import BaseModel
from ..tenant import TenantCtx
from ..guards import member_ctx, require_role
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/artifacts", tags=["artifact-tags"])
PM_PLUS = require_role({"owner","admin","pm","lead"})

class TagBody(BaseModel):
    name: str

@router.get("/tags")
def list_tags(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    # tags used in this project
    used = sb.table("artifact_tags").select("tag_id")\
            .eq("org_id", ctx.org_id).eq("project_id", project_id).execute().data or []
    tag_ids = [x["tag_id"] for x in used] or ["00000000-0000-0000-0000-000000000000"]
    rows = sb.table("tags").select("id,name").in_("id", tag_ids).execute().data or []
    return {"items": rows}

@router.get("/{artifact_id}/tags")
def artifact_tags(artifact_id: str, project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    ats = sb.table("artifact_tags").select("tag_id")\
          .eq("org_id", ctx.org_id).eq("project_id", project_id).eq("artifact_id", artifact_id).execute().data or []
    if not ats: return {"tags":[]}
    tids = [x["tag_id"] for x in ats]
    rows = sb.table("tags").select("id,name").in_("id", tids).execute().data or []
    return {"tags": rows}

@router.post("/{artifact_id}/tags/add")
def add_tag(artifact_id: str, body: TagBody, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    name = body.name.strip().lower()
    if not name: raise HTTPException(400, "empty tag")
    # ensure tag
    t = sb.table("tags").select("id").eq("org_id", ctx.org_id).eq("name", name).limit(1).execute().data
    if t: tag_id = t[0]["id"]
    else:
        tag_id = sb.table("tags").insert({"org_id": ctx.org_id, "name": name}).execute().data[0]["id"]
    # map
    sb.table("artifact_tags").upsert({
        "org_id": ctx.org_id, "project_id": project_id, "artifact_id": artifact_id, "tag_id": tag_id
    }).execute()
    return {"ok": True, "tag_id": tag_id, "name": name}

@router.post("/{artifact_id}/tags/remove")
def remove_tag(artifact_id: str, body: TagBody, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    name = body.name.strip().lower()
    t = sb.table("tags").select("id").eq("org_id", ctx.org_id).eq("name", name).limit(1).execute().data
    if not t: return {"ok": True}
    tag_id = t[0]["id"]
    sb.table("artifact_tags").delete().eq("org_id", ctx.org_id).eq("project_id", project_id)\
      .eq("artifact_id", artifact_id).eq("tag_id", tag_id).execute()
    return {"ok": True}

@router.get("/filter")
def filter_by_tags(project_id: str = Query(...), tags: str = Query(""), ctx: TenantCtx = Depends(member_ctx)):
    """
    tags: comma-separated names; returns artifact ids that have ALL tags
    """
    sb = get_user_supabase(ctx)
    names = [t.strip().lower() for t in tags.split(",") if t.strip()]
    if not names: return {"artifact_ids":[]}
    tids = sb.table("tags").select("id").eq("org_id", ctx.org_id).in_("name", names).execute().data or []
    if not tids: return {"artifact_ids":[]}
    ids = [x["id"] for x in tids]
    rows = sb.table("artifact_tags").select("artifact_id, tag_id")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).in_("tag_id", ids).execute().data or []
    # intersect by artifact_id count
    from collections import Counter
    c = Counter([r["artifact_id"] for r in rows])
    hit = [k for k,v in c.items() if v == len(ids)]
    return {"artifact_ids": hit}


Mount in server/main.py:

from .routers import artifact_tags
app.include_router(artifact_tags.router)

1B) CSV export endpoints

server/routers/csv_export.py

from fastapi import APIRouter, Depends, Query
from fastapi.responses import StreamingResponse
import io, csv
from ..tenant import TenantCtx
from ..guards import member_ctx
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/export", tags=["export"])

def _csv(rows, headers, filename):
    buf = io.StringIO(); w = csv.writer(buf); w.writerow(headers)
    for r in rows: w.writerow([r.get(h,"") for h in headers])
    buf.seek(0)
    return StreamingResponse(iter([buf.read()]), media_type="text/csv",
      headers={"Content-Disposition": f'attachment; filename="{filename}"'})

@router.get("/actions.csv")
def actions_csv(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    rows = sb.table("actions").select("id,title,owner,status,created_at,updated_at")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).order("created_at", desc=False).execute().data or []
    return _csv(rows, ["id","title","owner","status","created_at","updated_at"], "actions.csv")

@router.get("/risks.csv")
def risks_csv(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    rows = sb.table("risks").select("id,title,severity,owner,created_at,updated_at")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).order("created_at", desc=False).execute().data or []
    return _csv(rows, ["id","title","severity","owner","created_at","updated_at"], "risks.csv")

@router.get("/decisions.csv")
def decisions_csv(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    rows = sb.table("decisions").select("id,title,decided_by,created_at,updated_at")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).order("created_at", desc=False).execute().data or []
    return _csv(rows, ["id","title","decided_by","created_at","updated_at"], "decisions.csv")


Mount:

from .routers import csv_export
app.include_router(csv_export.router)

1C) Actions status update (for Kanban)

server/routers/actions_status.py

from fastapi import APIRouter, Depends, Query
from pydantic import BaseModel
from ..tenant import TenantCtx
from ..guards import require_role
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/actions", tags=["actions"])
PM_PLUS = require_role({"owner","admin","pm","lead"})

class StatusBody(BaseModel):
    status: str  # todo | in_progress | done

@router.post("/set-status")
def set_status(action_id: str, body: StatusBody, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    sb.table("actions").update({"status": body.status})\
      .eq("org_id", ctx.org_id).eq("project_id", project_id).eq("id", action_id).execute()
    return {"ok": True}


Mount:

from .routers import actions_status
app.include_router(actions_status.router)

2) Frontend
2A) Documents — tags UI & filter bar

client/src/components/TagsBar.tsx

import { useEffect, useState } from "react";

export function TagsFilterBar({ projectId, onChange }:{ projectId:string; onChange:(tags:string[])=>void }){
  const [avail,setAvail] = useState<{id:string;name:string}[]>([]);
  const [sel,setSel] = useState<string[]>([]);
  useEffect(()=>{ (async ()=>{
    const r = await fetch(`/api/artifacts/tags?project_id=${projectId}`, { credentials:"include" });
    if (r.ok) setAvail((await r.json()).items||[]);
  })(); },[projectId]);
  function toggle(name:string){
    const s = sel.includes(name) ? sel.filter(x=>x!==name) : [...sel, name];
    setSel(s); onChange(s);
  }
  return (
    <div className="flex flex-wrap gap-2">
      {avail.map(t=>(
        <button key={t.id} onClick={()=>toggle(t.name)}
          className={`px-2 py-1 rounded border text-xs ${sel.includes(t.name)?'bg-black text-white':''}`}>
          #{t.name}
        </button>
      ))}
    </div>
  );
}

export function ArtifactTagChips({ artifactId, projectId, canEdit }:{ artifactId:string; projectId:string; canEdit:boolean }){
  const [tags,setTags] = useState<{id:string;name:string}[]>([]);
  const [adding,setAdding] = useState(false);
  const [val,setVal] = useState("");

  async function load(){
    const r = await fetch(`/api/artifacts/${artifactId}/tags?project_id=${projectId}`, { credentials:"include" });
    if (r.ok) setTags((await r.json()).tags||[]);
  }
  useEffect(()=>{ load(); },[artifactId, projectId]);

  async function add(){ if(!val.trim()) return; 
    await fetch(`/api/artifacts/${artifactId}/tags/add?project_id=${projectId}`, {
      method:"POST", credentials:"include", headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:val.trim()})
    }); setVal(""); setAdding(false); load();
  }
  async function remove(name:string){
    await fetch(`/api/artifacts/${artifactId}/tags/remove?project_id=${projectId}`, {
      method:"POST", credentials:"include", headers:{'Content-Type':'application/json'}, body: JSON.stringify({name})
    }); load();
  }

  return (
    <div className="flex flex-wrap gap-1">
      {tags.map(t=>(
        <span key={t.id} className="px-1.5 py-0.5 rounded bg-neutral-200 text-[11px] flex items-center gap-1">
          #{t.name}{canEdit && <button onClick={()=>remove(t.name)} className="ml-1 text-xs">×</button>}
        </span>
      ))}
      {canEdit && !adding && <button className="text-xs underline" onClick={()=>setAdding(true)}>+ tag</button>}
      {canEdit && adding && (
        <span className="flex items-center gap-1">
          <input className="border rounded px-1 py-0.5 text-xs" value={val} onChange={e=>setVal(e.target.value)} placeholder="tag"/>
          <button className="text-xs" onClick={add}>Add</button>
          <button className="text-xs" onClick={()=>{setVal("");setAdding(false);}}>Cancel</button>
        </span>
      )}
    </div>
  );
}


Use it on Documents/Library page:

import { TagsFilterBar, ArtifactTagChips } from "@/components/TagsBar";

// top of page (above list)
<TagsFilterBar projectId={projectId!} onChange={async (names)=>{
  const qs = new URLSearchParams({ project_id: projectId!, tags: names.join(",") }).toString();
  const r = await fetch(`/api/artifacts/filter?${qs}`, { credentials:"include" });
  const ids = r.ok ? (await r.json()).artifact_ids : [];
  // apply client-side filter using ids (or refetch artifacts with filter if you have such API)
  setFilterIds(ids);
}} />

// in each artifact row/card:
<ArtifactTagChips artifactId={a.id} projectId={projectId!} canEdit={['owner','admin','pm','lead'].includes(role)} />

2B) CSV export buttons (Actions/Risks/Decisions page or dashboard)
<div className="flex gap-2">
  <a className="px-3 py-2 border rounded" href={`/api/export/actions.csv?project_id=${projectId}`} target="_blank" rel="noreferrer">Export Actions CSV</a>
  <a className="px-3 py-2 border rounded" href={`/api/export/risks.csv?project_id=${projectId}`} target="_blank" rel="noreferrer">Export Risks CSV</a>
  <a className="px-3 py-2 border rounded" href={`/api/export/decisions.csv?project_id=${projectId}`} target="_blank" rel="noreferrer">Export Decisions CSV</a>
</div>

2C) Impersonate (dev-only) bar

Patch client/src/lib/api.ts to allow runtime overrides (without rebuild):

// after existing DEV_AUTH logic:
const DEV_OVERRIDE = () => {
  try {
    const o = JSON.parse(localStorage.getItem("kap.devAuth") || "null");
    return o && o.dev === true ? o : null;
  } catch { return null; }
};

async function baseHeaders() {
  const override = DEV_OVERRIDE();
  if (DEV_AUTH || override) {
    return {
      "X-Dev-User": override?.user || DEV_USER,
      "X-Dev-Org":  override?.org  || DEV_ORG,
      "X-Dev-Role": override?.role || DEV_ROLE,
    } as Record<string,string>;
  }
  // ... existing JWT path ...
}


client/src/components/ImpersonateBar.tsx

import { useEffect, useState } from "react";

export default function ImpersonateBar(){
  const [enabled,setEnabled] = useState<boolean>(false);
  const [user,setUser] = useState(""); const [org,setOrg]=useState(""); const [role,setRole]=useState("member");

  useEffect(()=>{ try {
    const o = JSON.parse(localStorage.getItem("kap.devAuth") || "null");
    if (o) { setEnabled(!!o.dev); setUser(o.user||""); setOrg(o.org||""); setRole(o.role||"member"); }
  } catch {} },[]);

  function save(){
    localStorage.setItem("kap.devAuth", JSON.stringify({ dev:true, user, org, role }));
    location.reload();
  }
  function clear(){
    localStorage.removeItem("kap.devAuth"); location.reload();
  }

  if (import.meta.env.VITE_DEV_AUTH !== "1") return null;

  return (
    <div className="fixed left-0 right-0 bottom-0 z-[80] bg-black text-white text-xs px-3 py-2 flex items-center gap-2">
      <span className="opacity-70">Impersonate (dev)</span>
      <input className="bg-white text-black px-1 py-0.5 rounded" placeholder="user-uuid" value={user} onChange={e=>setUser(e.target.value)} />
      <input className="bg-white text-black px-1 py-0.5 rounded" placeholder="org-uuid" value={org} onChange={e=>setOrg(e.target.value)} />
      <select className="bg-white text-black px-1 py-0.5 rounded" value={role} onChange={e=>setRole(e.target.value)}>
        {["owner","admin","pm","lead","member","guest"].map(r=><option key={r} value={r}>{r}</option>)}
      </select>
      <button className="px-2 py-1 bg-white text-black rounded" onClick={save}>Apply</button>
      {enabled && <button className="px-2 py-1 border rounded" onClick={clear}>Clear</button>}
    </div>
  );
}


Add it to your authed layout (render once):

import ImpersonateBar from "@/components/ImpersonateBar";
// ...
<ImpersonateBar />

2D) Actions Kanban (drag & drop)

client/src/pages/ActionsKanban.tsx

import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";

const COLUMNS = [
  { key:"todo",        title:"Todo" },
  { key:"in_progress", title:"In Progress" },
  { key:"done",        title:"Done" },
];

export default function ActionsKanban(){
  const { projectId } = useParams();
  const [items,setItems] = useState<any[]>([]);
  const [role,setRole] = useState<string>("member");

  async function load(){
    const r = await fetch(`/api/actions/list?project_id=${projectId}`, { credentials:"include" }).catch(()=>null);
    if (r && r.ok) setItems((await r.json()).items||[]);
  }
  useEffect(()=>{ load(); },[projectId]);

  async function setStatus(id:string, status:string){
    await fetch(`/api/actions/set-status?action_id=${id}&project_id=${projectId}`, {
      method:"POST", credentials:"include", headers:{'Content-Type':'application/json'}, body: JSON.stringify({status})
    });
    setItems(prev=> prev.map(a=> a.id===id ? {...a, status} : a));
  }

  function onDrop(e:any, status:string){
    const id = e.dataTransfer.getData("text/plain");
    setStatus(id, status);
  }
  function onDragStart(e:any, id:string){ e.dataTransfer.setData("text/plain", id); }

  return (
    <div className="p-6">
      <h1 className="text-xl font-semibold mb-4">Actions Kanban</h1>
      <div className="grid md:grid-cols-3 gap-4">
        {COLUMNS.map(col=>(
          <div key={col.key} onDragOver={e=>e.preventDefault()} onDrop={e=>onDrop(e, col.key)}
               className="border rounded min-h-[320px] p-2">
            <div className="text-sm font-medium mb-2">{col.title}</div>
            <div className="space-y-2">
              {items.filter(a=>a.status===col.key).map(a=>(
                <div key={a.id} draggable onDragStart={e=>onDragStart(e, a.id)}
                     className="border rounded p-2 bg-white">
                  <div className="text-sm font-medium">{a.title}</div>
                  <div className="text-xs text-muted-foreground">{a.owner||"unassigned"}</div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}


(Add /api/actions/list if you don’t already have it; pattern mirrors other list endpoints.)

Add route & sidebar link:

{ path: "/projects/:projectId/actions/kanban", element: <ActionsKanban/> }

3) Quick validation

Spotlight finds artifacts; clicking an artifact jumps to Documents and pulses the card.

Tags: add a tag to a doc; filter by tag(s); client list narrows.

CSV: actions/risks/decisions download open in Excel/Sheets.

Impersonate: switch to member/guest → edit buttons hide; switch to admin/pm → they appear.

Kanban: drag items between columns; status persists.