Absolutely, Kris — here’s a clean, copy-paste Next Big Build that you can drop into Replit now. It:

Upgrades Sign-Off with real e-signature capture (typed name + IP + audit) + CSV export

Adds Apply All Safe button (already wired; this adds UI polish where missing)

Enforces visibility for Risks & Decisions (fail-closed, area-aware)

Adds bulk “Set Area” tagging for selected documents (area:<Area>)

Drops in a RLS Self-Test page + endpoint (green/red PASS for tenant isolation)

Fixes route aliases so /api/... and stripped /... both work (no more proxy heartburn)

I also included small patches to keep the “Manage Stages” link and pending-updates badge solid.

0) DB patches (run in Supabase SQL)
-- Sign-off docs: capture signer name/IP and meta
alter table public.signoff_docs
  add column if not exists signed_name text,
  add column if not exists signed_ip text,
  add column if not exists signed_meta jsonb;

-- Risks & Decisions: area columns for visibility and filtering
alter table public.risks
  add column if not exists area text;

alter table public.decisions
  add column if not exists area text;

create index if not exists idx_risks_area on public.risks(project_id, area);
create index if not exists idx_decisions_area on public.decisions(project_id, area);

select pg_notify('pgrst','reload schema');

1) Sign-Off Docs — e-signature capture + CSV export
1A) Upgrade token sign to record name + IP + audit

Patch server/routers/signoff_docs.py (public section):

from fastapi import Request  # add import

@pub.get("/signoff/doc/{token}", response_class=HTMLResponse)
def open_doc(token: str):
    # ... existing fetch + checks ...
    html = d.get("html") or f"<p>Download: {d.get('storage_path')}</p>"
    # updated sign form: typed name + confirm checkbox
    return HTMLResponse(f"""
      <html><body style="font-family:sans-serif;max-width:880px;margin:auto">
      {html}
      <hr/>
      <form method="POST" action="/api/signoff/docs/token-sign?token={token}">
        <label>Name (type to sign): <input name="signed_name" required/></label>
        <label style="margin-left:10px;">
          <input type="checkbox" name="confirm" required/> I agree and sign.
        </label>
        <br/><br/>
        <input type="submit" value="I acknowledge and sign"/>
      </form>
      </body></html>
    """)

@pub.post("/api/signoff/docs/token-sign")
def token_sign(token: str, request: Request):
    sbs = get_service_supabase()
    t = sbs.table("signoff_doc_tokens").select("*").eq("token", token).limit(1).execute().data
    if not t: raise HTTPException(404, "Invalid token")
    row = t[0]
    if row.get("used_at"): raise HTTPException(400, "Already signed")
    if datetime.now(timezone.utc) > datetime.fromisoformat(row["expires_at"]):
        raise HTTPException(400, "Link expired")

    form = dict((await request.form())) if hasattr(request, "form") else {}
    # In FastAPI sync, Request.form() is async; we can read manually via starlette in an async route.


Because FastAPI’s Request.form() is async, switch token_sign to async def:

@pub.post("/api/signoff/docs/token-sign")
async def token_sign(token: str, request: Request):
    sbs = get_service_supabase()
    t = sbs.table("signoff_doc_tokens").select("*").eq("token", token).limit(1).execute().data
    if not t: raise HTTPException(404, "Invalid token")
    row = t[0]
    if row.get("used_at"): raise HTTPException(400, "Already signed")
    if datetime.now(timezone.utc) > datetime.fromisoformat(row["expires_at"]):
        raise HTTPException(400, "Link expired")

    form = await request.form()
    signed_name = (form.get("signed_name") or "").strip()
    if not signed_name or "confirm" not in form: raise HTTPException(400, "Missing signature")
    client_ip = request.client.host if request.client else None

    # Update doc
    sbs.table("signoff_docs").update({
      "status":"signed",
      "signed_by": row["signer_email"],
      "signed_name": signed_name,
      "signed_ip": client_ip,
      "signed_meta": {"ua": request.headers.get("user-agent","")},
      "signed_at": datetime.now(timezone.utc).isoformat()
    }).eq("id", row["doc_id"]).execute()
    sbs.table("signoff_doc_tokens").update({"used_at": datetime.now(timezone.utc).isoformat()})\
      .eq("id", row["id"]).execute()

    # Audit
    d = sbs.table("signoff_docs").select("org_id,project_id").eq("id", row["doc_id"]).limit(1).execute().data[0]
    sbs.table("audit_events").insert({
      "org_id": d["org_id"], "project_id": d["project_id"], "actor_id": None,
      "kind": "signoff.doc.signed",
      "details": {"doc_id": row["doc_id"], "email": row["signer_email"], "name": signed_name, "ip": client_ip}
    }).execute()
    return {"ok": True}

1B) CSV Export for sign-off docs

Create server/routers/signoff_docs_export.py:

from fastapi import APIRouter, Depends, Query
from fastapi.responses import StreamingResponse
import io, csv, os
from ..tenant import TenantCtx
from ..guards import member_ctx, require_role
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/signoff/docs", tags=["signoff-docs"])
PM_PLUS = require_role({"owner","admin","pm"})

@router.get("/export.csv")
def export_signoff_docs(project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    rows = sb.table("signoff_docs").select("id,name,kind,status,stage_id,signed_by,signed_name,signed_ip,signed_at,created_at,created_by")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).order("created_at", desc=True).limit(2000).execute().data or []
    buf = io.StringIO(); w = csv.writer(buf)
    w.writerow(["id","name","kind","status","stage_id","signed_by","signed_name","signed_ip","signed_at","created_at","created_by"])
    for r in rows:
        w.writerow([r.get("id"), r.get("name"), r.get("kind"), r.get("status"), r.get("stage_id"),
                    r.get("signed_by"), r.get("signed_name"), r.get("signed_ip"), r.get("signed_at"),
                    r.get("created_at"), r.get("created_by")])
    buf.seek(0)
    return StreamingResponse(iter([buf.read()]), media_type="text/csv",
      headers={"Content-Disposition": 'attachment; filename="signoff_docs.csv"'})


Mount server/main.py:

from .routers import signoff_docs_export
app.include_router(signoff_docs_export.router)


UI button (SignoffDocs page toolbar):

import { downloadGET } from "@/lib/download";
<button className="px-3 py-2 border rounded" onClick={()=>downloadGET(`/api/signoff/docs/export.csv?project_id=${projectId}`, "signoff_docs.csv")}>
  Export CSV
</button>

2) Visibility enforcement — Risks & Decisions (fail-closed)
2A) Helper (you created visibility_guard.py earlier; if not, keep utils)

Use the same get_member_areas helper from earlier.

2B) Risks list (patch)

server/routers/risks_list.py (or wherever you list risks):

from ..utils.visibility import get_member_areas

@router.get("/list")
def list_risks(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    rows = sb.table("risks").select("id,title,severity,owner,area,created_at")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).order("created_at", desc=True).limit(1000).execute().data or []
    can_all, areas = get_member_areas(sb, ctx.org_id, project_id, ctx.user_id)
    if not can_all:
        rows = [r for r in rows if (r.get("area") in areas)]
    return {"items": rows}


For mutation endpoints (set_owner, set_severity, etc.), read the action-pattern you added: fail-closed and return generic 404 if user lacks area access.

2C) Decisions list (same)

server/routers/decisions_list.py:

from ..utils.visibility import get_member_areas

@router.get("/list")
def list_decisions(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    rows = sb.table("decisions").select("id,title,decided_by,area,created_at")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).order("created_at", desc=True).limit(1000).execute().data or []
    can_all, areas = get_member_areas(sb, ctx.org_id, project_id, ctx.user_id)
    if not can_all:
        rows = [r for r in rows if (r.get("area") in areas)]
    return {"items": rows}


(For mutation routes, copy the same area check you put on Actions.)

3) Bulk “Set Area” on Documents

UI — client/src/pages/Documents/Library.tsx (toolbar):

const [bulkArea, setBulkArea] = useState("");

async function bulkSetArea(){
  const ids = selectedIds(); if (!ids.length || !bulkArea.trim()) return;
  // we store area as a tag: area:<Area>
  await Promise.all(ids.map(id => postJSON(`/api/artifacts/${id}/tags/add?project_id=${projectId}`, { name: `area:${bulkArea.trim()}` })));
  toast({ title:"Area applied", description:`area:${bulkArea} to ${ids.length} document(s)` });
  reloadDocs();
}

<div className="flex items-center gap-2">
  <input className="border rounded p-2" placeholder="Area (e.g., HCM)" value={bulkArea} onChange={e=>setBulkArea(e.target.value)} />
  <button className="px-3 py-2 border rounded" onClick={bulkSetArea}>Set Area on Selected</button>
</div>

4) RLS Self-Test page (PASS/FAIL banner)
4A) Endpoint

server/routers/rls_selftest.py

from fastapi import APIRouter, Depends, Query
from ..tenant import TenantCtx
from ..guards import member_ctx
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/admin", tags=["admin"])

@router.get("/rls_selftest")
def rls_selftest(project_id: str = Query(...), other_project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    # Attempt to read a known table across other project
    try:
        r = sb.table("project_stages").select("id").eq("org_id", ctx.org_id).eq("project_id", other_project_id).limit(1).execute().data or []
        leak = len(r)>0
    except Exception:
        leak = False  # fail-closed
    return {"ok": (not leak), "leak": leak, "tested_against": other_project_id}


Mount in server/main.py:

from .routers import rls_selftest
app.include_router(rls_selftest.router)

4B) Admin page UI

client/src/pages/RlsSelfTest.tsx

import { useState } from "react";
import { useParams } from "react-router-dom";
import { getJSON } from "@/lib/authFetch";

export default function RlsSelfTest(){
  const { projectId } = useParams();
  const [other,setOther] = useState("");
  const [res,setRes] = useState<any>(null);
  async function run(){
    const d = await getJSON(`/api/admin/rls_selftest?project_id=${projectId}&other_project_id=${other}`);
    setRes(d);
  }
  return (
    <div className="p-6 space-y-3">
      <h1 className="text-xl font-semibold">RLS Self-Test</h1>
      <div className="flex gap-2">
        <input className="border rounded p-2" placeholder="Other Project UUID" value={other} onChange={e=>setOther(e.target.value)} />
        <button className="px-3 py-2 border rounded" onClick={run}>Run Test</button>
      </div>
      {res && (
        <div className={`px-3 py-2 rounded ${res.ok?'bg-green-50':'bg-red-50'}`}>
          {res.ok ? "PASS: no leak" : "FAIL: data leak observed"} (tested against {res.tested_against})
        </div>
      )}
    </div>
  );
}


Route:

{ path: "/projects/:projectId/admin/rls-selftest", element: <RlsSelfTest/> }

5) Route aliases (keep /api/... and stripped /... working)

server/main.py (add once, mirroring your actions/team aliases):

from fastapi import APIRouter

# RISKS alias: /risks/* -> /api/risks/*
from .routers import risks_list as risks_router  # adjust if you named differently
risks_alias = APIRouter(prefix="/risks", tags=["risks"])
for r in risks_router.router.routes:
    risks_alias.add_api_route(r.path.replace("/api/risks","") or "/", r.endpoint, methods=r.methods)
app.include_router(risks_alias)

# DECISIONS alias
from .routers import decisions_list as decisions_router
decisions_alias = APIRouter(prefix="/decisions", tags=["decisions"])
for r in decisions_router.router.routes:
    decisions_alias.add_api_route(r.path.replace("/api/decisions","") or "/", r.endpoint, methods=r.methods)
app.include_router(decisions_alias)

# UPDATES alias (if not already added)
from .routers import updates as updates_router
updates_alias = APIRouter(prefix="/updates", tags=["updates"])
for r in updates_router.router.routes:
    updates_alias.add_api_route(r.path.replace("/api/updates","") or "/", r.endpoint, methods=r.methods)
app.include_router(updates_alias)


(Adjust import names to match your files.)

6) Express proxy (final check)

Ensure /api is NOT path-rewritten and dev headers forward (you already patched this; keep as is).

7) Final checklist (2 min)

Composer shows “Manage stages” link; Stage Editor updates Area; Sign-Off doc draft/upload + request sign → token page; typed name signs; CSV export works.

Updates Review shows Apply All Safe; applies only ≥ threshold.

Visibility: non-view-all users only see allowed areas for Documents, Risks, Decisions; actions mutations require area authorization (you already added).

Bulk “Set Area” works via area tags.

RLS Self-Test: PASS green for another project UUID.

Sidebar badge ticks 15s.