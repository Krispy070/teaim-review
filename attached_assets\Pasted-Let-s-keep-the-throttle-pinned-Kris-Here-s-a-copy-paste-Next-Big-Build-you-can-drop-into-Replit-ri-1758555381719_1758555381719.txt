Let’s keep the throttle pinned, Kris. Here’s a copy-paste Next Big Build you can drop into Replit right now. It makes the app demo-proof and production-lean:

Admin Schema Doctor (detect missing tables/columns, show ready-to-copy DDL)

Stage Wizard Templates (one-click Workday templates; add to your current wizard)

Meeting Summaries → Propose (UI glue you can paste; you already mounted the backend)

Digest preview by topics (respect notify_* toggles)

Event formatters v2 (clean Slack/Teams messages per event)

Visibility-safe mutations (confirm) (mirrors your Actions pattern)

Dev impersonation stability (final guard)

I’ve kept each patch small and isolated.

0) Admin Schema Doctor
0A) Router — checks required tables/columns and returns suggested DDL

server/routers/schema_doctor.py

from fastapi import APIRouter, Depends
from ..tenant import TenantCtx
from ..guards import require_role
from ..deps import get_service_supabase

router = APIRouter(prefix="/api/admin", tags=["admin"])
ADMIN = require_role({"owner","admin"})

# Minimal set we depend on; expand as needed
REQUIRED = {
  "projects": ["id","code"],
  "artifacts": ["id","name","org_id","project_id","storage_bucket","storage_path","created_at"],
  "artifact_tags": ["org_id","project_id","artifact_id","tag_id"],
  "tags": ["id","org_id","name"],
  "project_stages": ["id","org_id","project_id","title","area","status","created_at"],
  "actions": ["id","org_id","project_id","title","owner","status","area","created_at","updated_at"],
  "risks": ["id","org_id","project_id","title","severity","owner","area","created_at","updated_at"],
  "decisions": ["id","org_id","project_id","title","decided_by","area","created_at","updated_at"],
  "summaries": ["artifact_id","org_id","project_id","actions","risks","decisions"],
  "pending_updates": ["id","org_id","project_id","change_type","operation","target_table","payload","status","confidence","created_at"],
  "share_links": ["token","org_id","project_id","artifact_id","expires_at"],
  "signoff_docs": ["id","org_id","project_id","name","status","signed_by","signed_name","signed_ip","signed_at","html","storage_bucket","storage_path"],
  "signoff_doc_tokens": ["token","org_id","project_id","doc_id","signer_email","expires_at","used_at"],
  "project_members": ["org_id","project_id","user_id","role"],
  "project_member_access": ["org_id","project_id","user_id","can_view_all","visibility_areas","can_sign_all","sign_areas"],
  "team_subscriptions": ["org_id","project_id","user_id","digest_weekly","digest_monthly","notify_actions","notify_risks","notify_decisions","notify_reminders"],
  "org_webhooks": ["org_id","enabled","slack_url","teams_url","generic_url"],
}

DDL_SNIPPETS = {
  "actions.area": "alter table public.actions add column if not exists area text;",
  "risks.area": "alter table public.risks add column if not exists area text;",
  "decisions.area": "alter table public.decisions add column if not exists area text;",
  "signoff_docs.signed_name": "alter table public.signoff_docs add column if not exists signed_name text;",
  "signoff_docs.signed_ip": "alter table public.signoff_docs add column if not exists signed_ip text;",
  "signoff_docs.signed_meta": "alter table public.signoff_docs add column if not exists signed_meta jsonb;",
}

@router.get("/schema_doctor")
def schema_doctor(ctx: TenantCtx = Depends(ADMIN)):
    sbs = get_service_supabase()
    missing: list[dict] = []
    suggestions: list[str] = []

    for table, cols in REQUIRED.items():
        try:
            info = sbs.postgrest._request("GET", f"/information_schema/columns", params={
              "select":"column_name,table_name", "table_schema":"eq.public", "table_name": f"eq.{table}"
            })
            have = {c["column_name"] for c in info.json()}
            if not have:
                missing.append({"table": table, "missing": "table"})
                continue
            lost = [c for c in cols if c not in have]
            if lost:
                missing.append({"table": table, "missing_columns": lost})
                for c in lost:
                    key = f"{table}.{c}"
                    if key in DDL_SNIPPETS: suggestions.append(DDL_SNIPPETS[key])
        except Exception:
            # If information_schema isn't exposed via PostgREST, provide generic advice
            missing.append({"table": table, "missing": "unknown"})

    return {"ok": len(missing)==0, "missing": missing, "suggested_sql": list(sorted(set(suggestions)))}


Mount in server/main.py:

from .routers import schema_doctor
app.include_router(schema_doctor.router)

0B) Admin page UI

client/src/pages/AdminSchemaDoctor.tsx

import { useEffect, useState } from "react";
import { getJSON } from "@/lib/authFetch";
import PageHeaderHint from "@/components/PageHeaderHint";

export default function AdminSchemaDoctor(){
  const [data,setData] = useState<any>(null); const [loading,setLoading]=useState(false);
  async function run(){
    setLoading(true);
    try{ setData(await getJSON("/api/admin/schema_doctor")); } catch(e){ setData({ok:false, error:String(e)}); }
    setLoading(false);
  }
  useEffect(()=>{ run(); },[]);
  return (
    <div className="p-6 space-y-3">
      <PageHeaderHint id="schema-doctor" title="Schema Doctor"
        intro="Detect missing tables/columns and get ready-to-copy DDL to fix local/dev."
        bullets={["Uses information_schema to check coverage","Shows SQL to add missing columns (e.g., area)"]}/>
      <button className="px-3 py-2 border rounded" onClick={run} disabled={loading}>{loading?"Checking…":"Re-run check"}</button>
      {data && (
        <div className="mt-3 space-y-3">
          <div className={`px-3 py-2 rounded ${data.ok?'bg-green-50':'bg-red-50'}`}>
            {data.ok ? "All required schema present" : "Missing items detected"}
          </div>
          {!data.ok && data.missing?.length>0 && (
            <div className="border rounded p-2 text-sm">
              {data.missing.map((m:any,i:number)=>(
                <div key={i} className="border-b last:border-0 py-1">
                  <b>{m.table}</b>: {m.missing || (m.missing_columns||[]).join(", ")}
                </div>
              ))}
            </div>
          )}
          {data.suggested_sql?.length>0 && (
            <div className="border rounded p-2">
              <div className="text-sm font-medium mb-1">Suggested SQL</div>
              <pre className="text-xs whitespace-pre-wrap">{data.suggested_sql.join("\n")}</pre>
            </div>
          )}
        </div>
      )}
    </div>
  );
}


Route:

{ path: "/admin/schema-doctor", element: <AdminSchemaDoctor/> }

2) Stage Wizard Templates
2A) Router: templates

server/routers/stages_templates.py

from fastapi import APIRouter

router = APIRouter(prefix="/api/stages", tags=["stages"])

TEMPLATES = {
  "workday_core": [
    {"title":"Discovery","area":"HCM"},
    {"title":"Build P1","area":"HCM"},
    {"title":"Test","area":"HCM"},
    {"title":"Cutover","area":"HCM"},
  ],
  "workday_payroll_finance": [
    {"title":"Discovery","area":"Payroll"},
    {"title":"Build P1","area":"Payroll"},
    {"title":"Test","area":"Payroll"},
    {"title":"Cutover","area":"Payroll"},
    {"title":"GL Alignment","area":"Financials"},
  ],
}

@router.get("/templates")
def templates():
    return {"items": [{"key":k, "label":k.replace('_',' ').title(), "stages":v} for k,v in TEMPLATES.items()]}


Mount:

from .routers import stages_templates
app.include_router(stages_templates.router)

2B) Wizard UI: “Apply template”

Patch client/src/pages/StageWizard.tsx:

import { getJSON } from "@/lib/authFetch";
const [tpls,setTpls]=useState<any[]>([]);

useEffect(()=>{ (async()=>{ try{ const d=await getJSON(`/api/stages/templates`); setTpls(d.items||[]);}catch{} })(); },[]);

async function applyTemplate(key:string){
  const t = (tpls||[]).find((x:any)=>x.key===key);
  if (!t) return;
  setRows(t.stages.map((s:any)=>({...s, start_date:"", end_date:""})));
}

// add a dropdown + button near Add Row
<select className="border rounded p-2" onChange={e=>applyTemplate(e.target.value)}>
  <option value="">(apply template)</option>
  {tpls.map(t=><option key={t.key} value={t.key}>{t.label}</option>)}
</select>

3) Meeting Summaries UI — “Propose as …” glue

Add minimal UI controls to whatever page renders summaries. Example:

// in MeetingSummaries.tsx
const [sel,setSel]=useState<{artifact_id:string; kind:"action"|"risk"|"decision"; index:number; area?:string}[]>([]);
function toggle(aid:string, kind:"action"|"risk"|"decision", idx:number, checked:boolean){
  const k = JSON.stringify({aid,kind,idx}); setSel(prev=>{
    const next = prev.filter(x => JSON.stringify({aid:x.artifact_id,kind:x.kind,idx:x.index})!==k);
    return checked ? [...next,{artifact_id:aid,kind, index:idx}] : next;
  });
}
async function propose(){
  await postJSON(`/api/summaries/propose?project_id=${projectId}`, { items: sel.map(x=>({...x, confidence:0.82})) });
  alert("Proposed to Updates Monitor");
}

// when rendering extracted arrays, e.g., decisions:
decisions.map((d, idx)=>(
  <label key={idx} className="flex items-center gap-2 text-sm">
    <input type="checkbox" onChange={e=>toggle(artifactId,"decision",idx,e.target.checked)} />
    <span>{d.title || d.text}</span>
  </label>
))
<button className="px-3 py-2 border rounded" onClick={propose}>Propose Selected</button>

4) Digest preview by topics (actions/risks/decisions)

Patch your digest preview endpoint to accept topics (comma-sep). Example in server/routers/digest.py:

@router.get("/preview")
def preview(project_id: str = Query(...), topics: str | None = None, ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    wanted = set([t.strip() for t in (topics or "actions,risks,decisions").split(",") if t.strip()])
    counts = {"actions":0,"risks":0,"decisions":0}
    if "actions" in wanted:
        counts["actions"] = cnt("actions")  # your existing cnt()
    if "risks" in wanted:
        counts["risks"] = cnt("risks")
    if "decisions" in wanted:
        counts["decisions"] = cnt("decisions")
    # build html accordingly (omit sections not in wanted)
    # return {"html": html, "counts": counts}


A quick UI tweak to let PM pick topics is optional.

5) Event formatters v2 (per-event tweaking)

You already added blocks/cards; you can optionally special-case:

def emit_event(...):
    # ...
    if kind=="review.applied":
        title = f"TEAIM: Review Applied • {details.get('table')} {details.get('target_id') or ''}"
    elif kind=="signoff.doc.signed":
        title = f"TEAIM: Document Signed • {details.get('doc_id')}"
    # rest unchanged

6) Visibility-safe mutations for Risks/Decisions (confirm mirror)

If any mutation route remains, use the same generic 404 + area check you added for Actions (example snippet included earlier). This keeps leaks closed.

7) Mounts checklist

In server/main.py, ensure the new routers are mounted once:

from .routers import schema_doctor, stages_templates, stages_batch, summaries_propose, signoff_docs_gen
app.include_router(schema_doctor.router)
app.include_router(stages_templates.router)
app.include_router(stages_batch.router)
app.include_router(summaries_propose.router)
app.include_router(signoff_docs_gen.router)

8) 2-minute validation

Schema Doctor shows green or lists missing columns with DDL to copy.

Stage Wizard → Apply “Workday Core” → rows fill → Save creates stages.

Meeting Summaries → check a few → Propose → updates appear in Monitor.

Digest Preview with topics returns only selected sections.

Webhooks still pretty in Slack/Teams.

Risk/Decision mutations reject unauthorized areas (404), admins pass.

Composer Kap Draft still works; sign captures name/IP.