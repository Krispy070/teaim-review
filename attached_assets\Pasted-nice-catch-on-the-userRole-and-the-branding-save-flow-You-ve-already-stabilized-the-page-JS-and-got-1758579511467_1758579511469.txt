nice catch on the userRole and the branding save flow. You’ve already stabilized the page/JS and got GET/POST working; the last pain points were the upload path + dev auth. Let’s push Next Big Build v2.5.1 that:

Makes branding fully usable end-to-end (upload, preview, persist)

Renders a Branded Header across the app (and on sign-off public pages)

Adds a safe logo proxy endpoint (so you don’t need public storage or signed URLs in the client)

Keeps dev auth/JWT quirks handled

Everything below is copy-paste. I’ve included small guards where needed.

1) Branding router — add safe logo proxy + tighten uploads
1A) Update server/routers/branding.py

Add helpers + a read-only logo proxy. We’ll prefer BRANDING_BUCKET, else ARTIFACTS_BUCKET, else "artifacts".

# server/routers/branding.py  (append/patch)

from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Query
from fastapi.responses import StreamingResponse
from ..tenant import TenantCtx
from ..guards import require_role, member_ctx
from ..deps import get_user_supabase, get_service_supabase
import os, datetime as dt, imghdr, mimetypes, io

router = APIRouter(prefix="/branding", tags=["branding"])  # prefix WITHOUT /api to match proxy

ADMIN = require_role({"owner","admin"})

def _bucket():
    return os.getenv("BRANDING_BUCKET") or os.getenv("ARTIFACTS_BUCKET") or "artifacts"

def _now_iso():
    return dt.datetime.now(dt.timezone.utc).isoformat()

def _validate_image(data: bytes, filename: str):
    typ = imghdr.what(None, h=data)
    if typ not in ("png","jpeg","jpg","gif","webp"):
        # try by extension as fallback
        ext = (filename or "").split(".")[-1].lower()
        if ext not in ("png","jpg","jpeg","gif","webp"):
            raise HTTPException(400, "Invalid image file")
    ctype = mimetypes.guess_type(filename)[0] or "image/png"
    return ctype

def _upload_logo(file: UploadFile, prefix: str, ctx: TenantCtx):
    sbs = get_service_supabase()
    bucket = _bucket()
    raw = file.file.read()
    ctype = _validate_image(raw, file.filename or "logo.png")
    key = f"org/{ctx.org_id}/branding/{prefix}__{dt.datetime.now(dt.timezone.utc).strftime('%Y%m%d_%H%M%S')}__{file.filename or 'logo'}"
    sbs.storage().from_(bucket).upload(key, raw, {"content-type": ctype, "upsert": True})
    return bucket, key, ctype

@router.get("/settings")
def get_settings(ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    r = sb.table("org_branding").select("*").eq("org_id", ctx.org_id).single().execute()
    return r.data or {"org_id": ctx.org_id, "theme_color":"#111111"}

@router.post("/settings")
def set_settings(body: dict, ctx: TenantCtx = Depends(ADMIN)):
    sb = get_user_supabase(ctx)
    body = dict(body or {})
    body["org_id"] = ctx.org_id
    body["updated_at"] = _now_iso()
    sb.table("org_branding").upsert(body, on_conflict="org_id").execute()
    return {"ok": True}

@router.post("/upload_customer")
def upload_customer_logo(file: UploadFile = File(...), ctx: TenantCtx = Depends(ADMIN)):
    bucket, key, ctype = _upload_logo(file, "customer", ctx)
    sb = get_user_supabase(ctx)
    sb.table("org_branding").upsert({
        "org_id": ctx.org_id, "customer_logo_bucket": bucket, "customer_logo_path": key,
        "updated_at": _now_iso()
    }, on_conflict="org_id").execute()
    return {"ok": True, "bucket": bucket, "path": key, "content_type": ctype}

@router.post("/upload_vendor")
def upload_vendor_logo(file: UploadFile = File(...), ctx: TenantCtx = Depends(ADMIN)):
    bucket, key, ctype = _upload_logo(file, "vendor", ctx)
    sb = get_user_supabase(ctx)
    sb.table("org_branding").upsert({
        "org_id": ctx.org_id, "vendor_logo_bucket": bucket, "vendor_logo_path": key,
        "updated_at": _now_iso()
    }, on_conflict="org_id").execute()
    return {"ok": True, "bucket": bucket, "path": key, "content_type": ctype}

# -------- SAFE LOGO PROXY --------
def _logo_info(sb, org_id: str, which: str):
    r = sb.table("org_branding").select("*").eq("org_id", org_id).single().execute().data
    if not r: return None, None
    if which == "customer":
        return r.get("customer_logo_bucket"), r.get("customer_logo_path")
    if which == "vendor":
        return r.get("vendor_logo_bucket"), r.get("vendor_logo_path")
    return None, None

@router.get("/logo")
def logo(which: str = Query(..., regex="^(customer|vendor)$"), ctx: TenantCtx = Depends(member_ctx)):
    sbs = get_service_supabase()
    sb = get_user_supabase(ctx)
    bucket, path = _logo_info(sb, ctx.org_id, which)
    if not bucket or not path:
        raise HTTPException(404, "Logo not set")
    try:
        data = sbs.storage().from_(bucket).download(path)
    except Exception:
        raise HTTPException(404, "Logo missing")
    ctype = mimetypes.guess_type(path)[0] or "image/png"
    return StreamingResponse(io.BytesIO(data), media_type=ctype)


Dev-safe: this uses member_ctx and service client to stream images, so you don’t need public storage URLs in the browser.

Mount (you already include router with alias; you changed prefix to /branding to match proxy):
server/main.py already lists it; if not:

from .routers import branding
app.include_router(branding.router)

2) Branding Settings page — use AuthFetch + preview via proxy

Patch client/src/pages/BrandingSettings.tsx (only the API calls & preview parts):

import { getJSON, postJSON } from "@/lib/authFetch";  // ensure using AuthFetch

// load settings
async function load(){
  try{ setS(await getJSON(`/branding/settings`)); }catch{}
}

// save
async function save(){
  setBusy(true);
  try{
    await postJSON(`/branding/settings`, s);
    setBusy(false); alert("Saved");
  }catch(e:any){
    setBusy(false); alert(`Save failed: ${String(e?.message||e)}`);
  }
}

// upload
async function upload(which:"customer"|"vendor", file: File){
  const fd = new FormData(); fd.append("file", file);
  const r = await fetch(`/branding/upload_${which}`, { method:"POST", credentials:"include", body: fd as any });
  if (!r.ok){ alert(await r.text()); return; }
  await load();
}

// Previews: <img src={`/branding/logo?which=customer&ts=${Date.now()}`} ... />
// and        <img src={`/branding/logo?which=vendor&ts=${Date.now()}`} ... />

{ s.customer_logo_path
  ? <img src={`/branding/logo?which=customer&ts=${Date.now()}`} alt="customer" className="h-6" />
  : <div className="text-xs text-muted-foreground">No logo uploaded</div> }

{ s.vendor_logo_path
  ? <img src={`/branding/logo?which=vendor&ts=${Date.now()}`} alt="vendor" className="h-6" />
  : <div className="text-xs text-muted-foreground">No logo uploaded</div> }


This guarantees correct auth headers + fixes the missing project_id/JWT issue via your authFetch and dev fallbacks.

3) Branded Header component

Create client/src/components/BrandedHeader.tsx:

import { useEffect, useState } from "react";

export default function BrandedHeader(){
  const [b,setB]=useState<any>(null);
  useEffect(()=>{ (async()=>{ try{
      const r = await fetch(`/branding/settings`, { credentials:"include" });
      if (r.ok) setB(await r.json());
  }catch{} })(); },[]);
  if (!b) return null;

  const color = b.theme_color || "#111111";

  return (
    <div className="w-full border-b" style={{borderColor:color}}>
      <div className="flex items-center justify-between p-2">
        <div className="flex items-center gap-2">
          {b.customer_logo_path ?
            <img src={`/branding/logo?which=customer`} alt="customer" className="h-6" /> : null}
          {b.customer_name ? <div className="text-sm font-medium">{b.customer_name}</div> : null}
        </div>
        {b.header_text && <div className="text-xs text-muted-foreground">{b.header_text}</div>}
        <div className="flex items-center gap-2">
          {b.vendor_logo_path ?
            <img src={`/branding/logo?which=vendor`} alt="vendor" className="h-6" /> : null}
          <div className="text-sm font-semibold" style={{color}}>TEAIM</div>
        </div>
      </div>
    </div>
  );
}


Use it once in your authed layout/top of App (above main content):

import BrandedHeader from "@/components/BrandedHeader";
// ...
<BrandedHeader />

4) Brand headers in sign-off HTML & public token page

You already injected branding header into the generator previously. If you haven’t, add this minimal render in the public page:

# server/routers/signoff_docs.py  (inside open_doc)
from .signoff_docs_gen import _branding_header  # reuse helper

bheader = _branding_header(sbs, d["org_id"])
return HTMLResponse(f"""
<html><body style='font-family:sans-serif;max-width:880px;margin:auto'>
{bheader}
{html}
<hr/>
<form method="POST" action="/api/signoff/docs/token-sign?token={token}">
  <label>Name: <input name="signed_name" required/></label>
  <label style="margin-left:10px;"><input type="checkbox" name="confirm" required/> I agree and sign.</label>
  <br/><br/>
  <input type="submit" value="I acknowledge and sign"/>
</form>
</body></html>""")


(You already added name/IP capture earlier.)

5) Route mounts / aliases (confirm)

Make sure in server/main.py:

from .routers import branding
app.include_router(branding.router)

# If your proxy sometimes strips /api, branding already uses /branding (no /api) so it’s safe.

6) Quick test (dev)
# 1) GET settings (dev headers via your browser)
# 2) Save JSON: customer_name, vendor_name, theme_color, header_text
# 3) Upload customer logo: pick PNG/JPG
# 4) Upload vendor logo
# 5) Header should show both logos; public sign-off page shows them too


If you want storage absolutely private in prod, we’ll add a small /api/branding/logo/{which} signed-URL or streaming proxy behind auth (we already implemented the streaming proxy).

Heads-up on the dashboard “learning” you mentioned

The Method Learner seeds we dropped (metrics table + insights page + automatic stage.signed capture) give us the backbone to learn schedule medians per stage/area. Next sprint we can:

compute late/early flags by comparing planned dates vs actual sign times,

plot phase velocity & attention hotspots,

feed the dashboard’s smart tiles (“P1 Integrations typically takes 40–50 days; your median is trending +12d”)

Say when, and I’ll paste those analytics patches too.

Why saving/uploading now “just works”

Auth: Branding endpoints use your dev header fallbacks (member_ctx) and service client for storage streaming.

Routing: Router prefix is /branding (no /api) so it survives Express /api stripping.

Client: BrandingSettings uses authFetch wrappers (adds X-Dev/JWT + project_id guard), and previews call /branding/logo?which=... which streams bytes from Supabase via FastAPI.

If anything still barks in dev, send me the console/log snippet and I’ll zero it out.