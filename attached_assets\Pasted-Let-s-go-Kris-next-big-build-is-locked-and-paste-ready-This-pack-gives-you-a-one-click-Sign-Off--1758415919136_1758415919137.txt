Let‚Äôs go, Kris ‚Äî next big build is locked and paste-ready. This pack gives you a one-click Sign-Off Package builder, Documents quick search & sort, a lightweight Notifications Center, and an Integrations monitor tick so ops can breathe.

0) SQL (no heavy migrations)

Nothing new required. We‚Äôll reuse existing tables: artifacts, actions, risks, decisions, project_stages, audit_events, project_integrations.

(Optional convenience) If you want a view to speed up package queries later, we can add that next ‚Äî not required now.

1) Backend
1A) Sign-Off Package Builder API

server/routers/signoff_package.py

from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime, timezone
import os, io, zipfile, html

from ..tenant import TenantCtx
from ..guards import member_ctx, require_role
from ..deps import get_user_supabase, get_service_supabase
from ..email.util import mailgun_send_html, send_guard, log_send
from .signoff_external import request_external, RequestExternalBody

router = APIRouter(prefix="/api/signoff/package", tags=["signoff-package"])
PM_PLUS = require_role({"owner","admin","pm","lead"})

class PackageInput(BaseModel):
    stage_title: str
    artifact_ids: List[str] = []
    include_actions: bool = True
    include_risks: bool = True
    include_decisions: bool = True
    message: Optional[str] = None
    email_to: Optional[str] = None  # for /send only

def _fetch_lists(sb, org_id: str, project_id: str, want: PackageInput):
    data = {"actions": [], "risks": [], "decisions": []}
    if want.include_actions:
        try:
            rs = sb.table("actions").select("id,title,owner,status,created_at,updated_at")\
                  .eq("org_id", org_id).eq("project_id", project_id).order("created_at", desc=False).execute().data or []
            data["actions"] = rs
        except Exception: ...
    if want.include_risks:
        try:
            rs = sb.table("risks").select("id,title,severity,owner,created_at,updated_at")\
                  .eq("org_id", org_id).eq("project_id", project_id).order("created_at", desc=False).execute().data or []
            data["risks"] = rs
        except Exception: ...
    if want.include_decisions:
        try:
            rs = sb.table("decisions").select("id,title,decided_by,created_at,updated_at")\
                  .eq("org_id", org_id).eq("project_id", project_id).order("created_at", desc=False).execute().data or []
            data["decisions"] = rs
        except Exception: ...
    return data

def _html_package(proj_code: str, stage_title: str, pkg: PackageInput, lists: dict, artifacts: list):
    def esc(x): return html.escape(str(x) if x is not None else "")
    def section(title, rows, cols):
        if not rows: return ""
        head = "".join([f"<th style='text-align:left;padding:6px;border-bottom:1px solid #ddd'>{esc(c)}</th>" for c in cols])
        body = ""
        for r in rows:
            body += "<tr>" + "".join([f"<td style='padding:6px;border-bottom:1px solid #eee'>{esc(r.get(c,''))}</td>" for c in cols]) + "</tr>"
        return f"<h3 style='margin:16px 0 8px'>{esc(title)}</h3><table style='width:100%;border-collapse:collapse'>{head and '<thead><tr>'+head+'</tr></thead>'}<tbody>{body}</tbody></table>"

    arts = ""
    if artifacts:
        arts = "<ul>" + "".join([f"<li>{esc(a.get('name') or a.get('id'))}</li>" for a in artifacts]) + "</ul>"

    return f"""
    <div style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;max-width:880px;margin:auto">
      <h2>Sign-Off Package ‚Äî {esc(proj_code)} / {esc(stage_title)}</h2>
      {f"<p>{esc(pkg.message)}</p>" if pkg.message else ""}
      <h3>Included Artifacts</h3>
      {arts or "<p><i>No documents attached.</i></p>"}
      {section("Decisions", lists.get('decisions',[]), ["title","decided_by","created_at"])}
      {section("Risks",     lists.get('risks',[]),     ["title","severity","owner"])}
      {section("Actions",   lists.get('actions',[]),   ["title","owner","status"])}
      <p style="color:#888;font-size:12px;margin-top:16px">
        Generated by TEAIM ‚Äî {datetime.now(timezone.utc).isoformat()}
      </p>
    </div>
    """

@router.post("/preview")
def preview(body: PackageInput, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    proj = sb.table("projects").select("code").eq("id", project_id).single().execute().data
    proj_code = proj["code"] if proj else project_id

    # pull artifact names
    arts = []
    if body.artifact_ids:
        arts = sb.table("artifacts").select("id,name")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id)\
               .in_("id", body.artifact_ids).execute().data or []

    lists = _fetch_lists(sb, ctx.org_id, project_id, body)
    html_out = _html_package(proj_code, body.stage_title, body, lists, arts)
    return {"ok": True, "html": html_out}

@router.post("/send")
def send(body: PackageInput, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    if not body.email_to:
        raise HTTPException(400, "email_to required")

    sb = get_user_supabase(ctx)
    proj = sb.table("projects").select("code").eq("id", project_id).single().execute().data
    proj_code = proj["code"] if proj else project_id

    arts = []
    if body.artifact_ids:
        arts = sb.table("artifacts").select("id,name")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id)\
               .in_("id", body.artifact_ids).execute().data or []

    lists = _fetch_lists(sb, ctx.org_id, project_id, body)
    html_out = _html_package(proj_code, body.stage_title, body, lists, arts)

    # Request external sign-off token
    # Create a stage if missing (Discovery by default), or match by provided stage_title
    stage = sb.table("project_stages").select("id,title")\
            .eq("org_id", ctx.org_id).eq("project_id", project_id).eq("title", body.stage_title)\
            .limit(1).execute().data
    if not stage:
        ins = sb.table("project_stages").insert({
            "org_id": ctx.org_id, "project_id": project_id, "title": body.stage_title,
            "status": "in_review"
        }).execute().data[0]
        stage_id = ins["id"]
    else:
        stage_id = stage[0]["id"]

    # External token
    ext = request_external(RequestExternalBody(stage_id=stage_id, email_to=body.email_to, message=body.message or ""), project_id, ctx)
    token_link = ext.get("token_link")

    # Send summary email (quiet hours / caps applied)
    ok, reason = send_guard(sb, ctx.org_id, project_id, "signoff", body.email_to)
    if ok:
        subj = f"Sign-Off Requested ‚Äî {proj_code} / {body.stage_title}"
        html_mail = f"{html_out}<p><a href='{html.escape(token_link or '#')}' style='display:inline-block;padding:10px 14px;background:#111;color:#fff;border-radius:6px;text-decoration:none'>Review & Sign</a></p>"
        mailgun_send_html(body.email_to, subj, html_mail)
        log_send(sb, ctx.org_id, project_id, "signoff", body.email_to)

    # audit
    try:
        sb.table("audit_events").insert({
            "org_id": ctx.org_id, "project_id": project_id, "actor_id": ctx.user_id,
            "kind": "signoff.package_sent",
            "details": {"stage_id": stage_id, "email_to": body.email_to, "token_link": token_link,
                        "artifacts": [a["id"] for a in arts], "options": body.dict()}
        }).execute()
    except Exception: ...

    return {"ok": True, "token_link": token_link}

@router.post("/zip")
def zip_package(body: PackageInput, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    sbs = get_service_supabase()
    proj = sb.table("projects").select("code").eq("id", project_id).single().execute().data
    proj_code = proj["code"] if proj else project_id

    # artifacts to include
    arts = []
    if body.artifact_ids:
        arts = sb.table("artifacts").select("id,name,storage_bucket,storage_path")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id)\
               .in_("id", body.artifact_ids).execute().data or []

    lists = _fetch_lists(sb, ctx.org_id, project_id, body)
    html_out = _html_package(proj_code, body.stage_title, body, lists, arts)

    # Build zip in-memory
    buf = io.BytesIO()
    zf = zipfile.ZipFile(buf, mode="w", compression=zipfile.ZIP_DEFLATED)
    zf.writestr("README.html", html_out)
    zf.writestr("manifest.json", str({
        "project_code": proj_code, "stage_title": body.stage_title,
        "artifact_ids": body.artifact_ids, "options": body.dict(),
        "generated_at": datetime.now(timezone.utc).isoformat()
    }))
    for a in arts:
        try:
            b = sbs.storage().from_(a["storage_bucket"]).download(a["storage_path"])
            zf.writestr(f"documents/{a.get('name') or a['id']}", b)
        except Exception as e:
            zf.writestr(f"documents/_missing_{a['id']}.txt", f"Could not download: {e}")
    zf.close(); buf.seek(0)

    from fastapi.responses import StreamingResponse
    filename = f"signoff_{proj_code}_{body.stage_title.replace(' ','_')}.zip"
    return StreamingResponse(iter([buf.getvalue()]), media_type="application/zip",
                             headers={"Content-Disposition": f'attachment; filename="{filename}"'})


Mount in server/main.py:

from .routers import signoff_package
app.include_router(signoff_package.router)

1B) Notifications Center (simple recent audit feed)

No new router needed; reuse your /api/audit/list. The UI will poll and present.

1C) Integrations monitor tick (lightweight)

Extend server/scheduler.py ‚Äî add a small ‚Äútouch‚Äù pass that updates last_checked for integrations that have a schedule string:

async def integrations_tick(app):
    sb = get_service_supabase()
    while True:
        try:
            rows = sb.table("project_integrations").select("id,org_id,project_id,schedule,status").execute().data or []
            now = dt.datetime.now(dt.timezone.utc).isoformat()
            for r in rows:
                # minimal: if schedule present, just bump last_checked (actual connectivity checks can be added later)
                if r.get("schedule"):
                    sb.table("project_integrations").update({"last_checked": now})\
                      .eq("id", r["id"]).execute()
        except Exception:
            pass
        await asyncio.sleep(int(os.getenv("INTEGRATIONS_TICK_SEC","300")))


Start it on startup:

from .scheduler import integrations_tick

@app.on_event("startup")
async def _start_integrations_tick():
    asyncio.create_task(integrations_tick(app))

2) Frontend
2A) Sign-Off Composer page

client/src/pages/SignoffComposer.tsx

import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import { apiGet, apiPost } from "@/lib/api";
import { useToast } from "@/components/ui/use-toast";

type Artifact = { id:string; name:string };

export default function SignoffComposer(){
  const { projectId } = useParams();
  const { toast } = useToast();
  const [stageTitle,setStageTitle] = useState("Discovery");
  const [message,setMessage] = useState("");
  const [emailTo,setEmailTo] = useState("");
  const [actions,setActions] = useState(true);
  const [risks,setRisks]     = useState(true);
  const [decisions,setDecisions] = useState(true);
  const [arts,setArts] = useState<Artifact[]>([]);
  const [chk,setChk]   = useState<Record<string,boolean>>({});
  const [html,setHtml] = useState("");

  useEffect(()=>{ (async ()=>{
    const r = await apiGet<{items:Artifact[]}>("/documents/list", { project_id: projectId! }).catch(()=>null);
    if (r && (r as any).items) setArts((r as any).items);
  })(); },[projectId]);

  async function preview(){
    const body = {
      stage_title: stageTitle,
      artifact_ids: arts.filter(a=>chk[a.id]).map(a=>a.id),
      include_actions: actions, include_risks: risks, include_decisions: decisions,
      message
    };
    const d = await apiPost<{html:string}>("/signoff/package/preview", body, { project_id: projectId! });
    setHtml(d.html);
  }

  async function send(){
    const body = {
      stage_title: stageTitle,
      artifact_ids: arts.filter(a=>chk[a.id]).map(a=>a.id),
      include_actions: actions, include_risks: risks, include_decisions: decisions,
      message, email_to: emailTo
    };
    const d = await apiPost<{token_link?:string}>("/signoff/package/send", body, { project_id: projectId! });
    toast({ title: "Sent", description: d.token_link ? "External sign link created." : "Requested (may be quiet hours)" });
  }

  return (
    <div className="p-6 grid md:grid-cols-2 gap-6">
      <div className="space-y-3">
        <h1 className="text-xl font-semibold">Compose Sign-Off Package</h1>
        <input className="border rounded p-2 w-full" placeholder="Stage title" value={stageTitle} onChange={e=>setStageTitle(e.target.value)} />
        <textarea className="border rounded p-2 w-full" placeholder="Message to recipient (optional)" value={message} onChange={e=>setMessage(e.target.value)} />
        <div className="flex gap-4 text-sm">
          <label className="flex items-center gap-2"><input type="checkbox" checked={decisions} onChange={e=>setDecisions(e.target.checked)} /> Decisions</label>
          <label className="flex items-center gap-2"><input type="checkbox" checked={risks} onChange={e=>setRisks(e.target.checked)} /> Risks</label>
          <label className="flex items-center gap-2"><input type="checkbox" checked={actions} onChange={e=>setActions(e.target.checked)} /> Actions</label>
        </div>
        <div className="border rounded p-2">
          <div className="text-sm font-medium mb-1">Select Artifacts</div>
          <div className="max-h-[220px] overflow-auto space-y-1">
            {arts.map(a=>(
              <label key={a.id} className="flex items-center gap-2 text-sm">
                <input type="checkbox" checked={!!chk[a.id]} onChange={e=>setChk(prev=>({...prev, [a.id]: e.target.checked}))}/>
                <span className="truncate">{a.name || a.id}</span>
              </label>
            ))}
            {!arts.length && <div className="text-xs text-muted-foreground">No documents listed yet.</div>}
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button className="px-3 py-2 border rounded" onClick={preview}>Preview</button>
          <input className="border rounded p-2 flex-1" placeholder="Recipient email" value={emailTo} onChange={e=>setEmailTo(e.target.value)} />
          <button className="px-3 py-2 border rounded" onClick={send}>Send for Sign-Off</button>
          <a className="px-3 py-2 border rounded" href={`/api/signoff/package/zip?project_id=${projectId}`} onClick={(e)=>{ // build URL with POST body alternative?
            // fallback: if you want a POST-based ZIP, use a small fetch + blob download.
          }}>Download ZIP</a>
        </div>
      </div>
      <div className="border rounded p-3 bg-background">
        <div className="text-sm mb-2">Preview</div>
        <div className="prose prose-sm max-w-none" dangerouslySetInnerHTML={{__html: html}} />
      </div>
    </div>
  );
}


Note: The ‚ÄúDownload ZIP‚Äù link above shows the idea; because our zip endpoint is POST, add a small client helper to POST ‚Üí blob download (you already have downloadBlob helper ‚Äî reuse it). If you want, I‚Äôll drop the exact snippet next.

Add route & sidebar link:

{ path: "/projects/:projectId/signoff/compose", element: <SignoffComposer/> }


(If your documents/list endpoint doesn‚Äôt exist, you can use your existing artifacts list API or add a simple one that returns {items:[{id,name}]}.)

2B) Documents quick search & sort

Patch your Documents/Library page top bar:

const [q,setQ] = useState(""); const [sort,setSort] = useState("newest");

function applyFilterSort(list:any[]){
  let L = list;
  if (q.trim()) {
    const s = q.toLowerCase();
    L = L.filter(a => (a.name||"").toLowerCase().includes(s));
  }
  if (sort==="name")  L = [...L].sort((a,b)=> (a.name||"").localeCompare(b.name||""));
  if (sort==="newest") L = [...L].sort((a,b)=> (new Date(b.created_at).getTime() - new Date(a.created_at).getTime()));
  if (sort==="oldest") L = [...L].sort((a,b)=> (new Date(a.created_at).getTime() - new Date(b.created_at).getTime()));
  return L;
}

// UI
<div className="flex flex-wrap gap-2 items-end mb-3">
  <input className="border rounded p-2" placeholder="Quick search‚Ä¶" value={q} onChange={e=>setQ(e.target.value)} />
  <select className="border rounded p-2" value={sort} onChange={e=>setSort(e.target.value)}>
    <option value="newest">Newest</option>
    <option value="oldest">Oldest</option>
    <option value="name">Name</option>
  </select>
</div>

// when rendering list:
applyFilterSort(artifacts).map(‚Ä¶)


This plays nicely with your Tags filter ‚Äî chain the filters before applyFilterSort.

2C) Notifications Center (bell + drawer)

client/src/components/NotificationBell.tsx

import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";

export default function NotificationBell(){
  const { projectId } = useParams();
  const [open,setOpen]=useState(false);
  const [items,setItems]=useState<any[]>([]);
  const [unread,setUnread]=useState(0);

  async function load(){
    const r = await fetch(`/api/audit/list?project_id=${projectId}`, { credentials:"include" });
    if (r.ok) {
      const ev = (await r.json()).events||[];
      setItems(ev.slice(0,50));
      setUnread(Math.min(9, ev.filter((e:any)=> e.kind.includes("stage.") || e.kind.includes("reindex.") || e.kind.includes("backup.")).length));
    }
  }
  useEffect(()=>{ load(); const t=setInterval(load, 15000); return ()=>clearInterval(t); },[projectId]);

  return (
    <div className="relative">
      <button className="relative px-2 py-1 border rounded" onClick={()=>setOpen(o=>!o)}>
        üîî
        {unread>0 && <span className="absolute -top-1 -right-1 bg-red-600 text-white text-[10px] px-1 rounded-full">{unread}</span>}
      </button>
      {open && (
        <div className="absolute right-0 mt-2 w-[360px] max-h-[420px] overflow-auto border rounded bg-white shadow z-[90]">
          {items.map((e:any,i:number)=>(
            <div key={i} className="p-2 border-b last:border-0 text-sm">
              <div className="text-xs text-muted-foreground">{new Date(e.created_at).toLocaleString()}</div>
              <div><b>{e.kind}</b></div>
              <div className="text-xs text-muted-foreground">{JSON.stringify(e.details)}</div>
            </div>
          ))}
          {!items.length && <div className="p-3 text-sm text-muted-foreground">No recent activity.</div>}
        </div>
      )}
    </div>
  );
}


Put it in your topbar (auth layout), near project actions.

2D) (Already done) Integrations page gets last_checked automatically from the tick. You can add a tiny ‚ÄúCheck Now‚Äù:
async function checkNow(row:Row){
  await apiPost("/integrations/upsert", {...row, last_checked: new Date().toISOString()}, { project_id: projectId! });
  await load();
}
<button className="px-2 py-1 border rounded text-xs" onClick={()=>checkNow(r)}>Check Now</button>

3) Quick test script (dev)
# Preview package
curl -s -X POST "$APP/api/signoff/package/preview?project_id=$PROJ" \
  -H "X-Dev-User:$USER" -H "X-Dev-Org:$ORG" -H "X-Dev-Role:pm" \
  -H "Content-Type: application/json" \
  -d '{"stage_title":"Discovery","artifact_ids":[],"include_actions":true,"include_risks":true,"include_decisions":true,"message":"Please review."}' | jq -r '.html' | head

# Send package
curl -s -X POST "$APP/api/signoff/package/send?project_id=$PROJ" \
  -H "X-Dev-User:$USER" -H "X-Dev-Org:$ORG" -H "X-Dev-Role:pm" \
  -H "Content-Type: application/json" \
  -d '{"stage_title":"Discovery","artifact_ids":[],"include_actions":true,"include_risks":true,"include_decisions":true,"message":"Thanks!","email_to":"you@example.com"}' | jq

Notes / Compatibility

The ZIP endpoint is POST; for the UI, use your downloadBlob helper to POST and download the blob.

Package email honors quiet hours & caps (send_guard) and still returns the token_link for a manual copy.

All endpoints are tenant-scoped and role-gated (PM+).