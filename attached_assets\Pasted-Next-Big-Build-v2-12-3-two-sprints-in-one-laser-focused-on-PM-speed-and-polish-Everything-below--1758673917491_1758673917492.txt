Next Big Build v2.12.3 (two sprints in one), laser-focused on PM speed and polish. Everything below is copy-paste ready, Brand v2–aware, and dev-safe (all new endpoints fail gracefully when tables are missing).

What lands now:

Request Sign-Off Modal v3.2 → v3.3: global member search, area chips, CC all Leads/PMs presets, optional message, remembers last recipients per stage

Stage Editor date v2: duration-preserving sync both ways + combined undo (Revert last) with toast

Digest deep links open UI: Actions/Audit pages auto-open filters & scroll to exact row

Wellness Admin trend: “Last 7/30 days” trend line + Top Responders CSV, per-user modal sparkline & date range (from previous build)

1) Request Sign-Off v3.3 (global search, CC presets, remember last)
1A) Backend — add cc_all_pms support

server/routers/stages_request_sign.py (extend existing)

class RequestBatch(BaseModel):
    stage_id: str
    emails: List[str] = Field(min_items=1)
    cc: Optional[List[str]] = None
    cc_all_leads: bool = False
    cc_all_pms: bool = False       # NEW
    title: Optional[str] = "Stage Sign-Off"
    area: Optional[str] = None
    message: Optional[str] = None
    expires_hours: int = 120

@router.post("/request_signoff_batch")
def request_signoff_batch(body: RequestBatch, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx); sbs = get_service_supabase()

    # find/create doc (same as before)...

    # derive CC list
    cc_list = set([e.strip() for e in (body.cc or []) if e.strip()])
    # leads
    if body.cc_all_leads:
        try:
            m = sb.table("project_members").select("user_id,role")\
                .eq("org_id", ctx.org_id).eq("project_id", project_id).execute().data or []
            leads = [x["user_id"] for x in m if (x.get("role") or "").lower()=="lead"]
            prof = sb.table("users_profile").select("user_id,email").in_("user_id", leads).execute().data or []
            for p in prof:
                if p.get("email"): cc_list.add(p["email"])
        except Exception: ...
    # PMs
    if body.cc_all_pms:
        try:
            m = sb.table("project_members").select("user_id,role")\
                .eq("org_id", ctx.org_id).eq("project_id", project_id).execute().data or []
            pms = [x["user_id"] for x in m if (x.get("role") or "").lower()=="pm"]
            prof = sb.table("users_profile").select("user_id,email").in_("user_id", pms).execute().data or []
            for p in prof:
                if p.get("email"): cc_list.add(p["email"])
        except Exception: ...

    # send tokens (unchanged)...

    # optional FYI to CC (unchanged) ...
    # audit (unchanged) ...

    return {"ok": True, "sent": sent, "cc": sorted(list(cc_list))}


(You already mounted this router earlier.)

1B) Frontend — Modal v3.3 with presets + remember last recipients

client/src/components/SignoffRequestModal.tsx (replace your v3.x)

import { useEffect, useMemo, useRef, useState } from "react";
import { getJSON } from "@/lib/authFetch";

const DEFAULT_AREAS = ["HCM","Payroll","Financials","Time","Integrations","Security","Reporting","Cutover"];

export default function SignoffRequestModal({
  projectId, stageId, stageTitle, stageArea, onClose
}:{
  projectId: string; stageId: string; stageTitle?: string; stageArea?: string; onClose: ()=>void
}){
  const [members,setMembers]=useState<{user_id:string;email:string;role?:string;can_sign_all?:boolean;sign_areas?:string[]}[]>([]);
  const [signers,setSigners]=useState<typeof members>([]);
  const [q,setQ]=useState("");
  const [area,setArea]=useState(stageArea||"");
  const [picked,setPicked]=useState<string[]>([]);
  const [cc,setCc]=useState<string>("");
  const [ccAllLeads,setCcAllLeads]=useState(false);
  const [ccAllPMs,setCcAllPMs]=useState(false);
  const [msg,setMsg]=useState<string>("");
  const [busy,setBusy]=useState(false);
  const inputRef = useRef<HTMLInputElement|null>(null);

  const storeKey = `kap.stageReq.${projectId}.${stageId}`;

  useEffect(()=>{ inputRef.current?.focus(); },[]);

  // load members + previous selection
  useEffect(()=>{ (async()=>{
    try{
      const m = await getJSON(`/api/members/all?project_id=${projectId}`); setMembers(m.items||[]);
      const d = await getJSON(`/api/members/signers?project_id=${projectId}${stageArea?`&area=${encodeURIComponent(stageArea)}`:""}`); setSigners(d.items||[]);
    }catch{ setMembers([]); setSigners([]); }
    try{
      const saved = JSON.parse(localStorage.getItem(storeKey) || "{}");
      if (saved.emails) setPicked(saved.emails);
      if (saved.cc) setCc(saved.cc);
      if (saved.area) setArea(saved.area);
      if (saved.message) setMsg(saved.message);
      if (saved.ccAllLeads) setCcAllLeads(true);
      if (saved.ccAllPMs) setCcAllPMs(true);
    }catch{}
  })(); },[projectId, stageArea, storeKey]);

  const hits = useMemo(()=>{
    const pool = members.map(m=>{
      const s = signers.find(x=>x.user_id===m.user_id);
      const allowed = s?.allowed || m.can_sign_all || (area && (m.sign_areas||[]).includes(area));
      return {...m, allowed};
    });
    const qq = q.toLowerCase();
    return pool.filter(p=>{
      const matchQ = !qq || (p.email||"").toLowerCase().includes(qq) || (p.role||"").toLowerCase().includes(qq);
      const matchArea = !area || p.can_sign_all || (p.sign_areas||[]).includes(area);
      return matchQ && matchArea;
    }).sort((a,b)=> (a.allowed===b.allowed) ? ((a.role||"").localeCompare(b.role||"")) : (a.allowed? -1 : 1));
  },[members, signers, q, area]);

  function toggle(email:string){
    setPicked(p => p.includes(email) ? p.filter(x=>x!==email) : [...p, email]);
  }

  function applyPreset(which:"leads"|"pms"){
    const wanted = which==="leads" ? ["lead"] : ["pm"];
    const emails = hits.filter(h=> wanted.includes((h.role||"").toLowerCase()) ).map(h=>h.email);
    setPicked(prev => Array.from(new Set([ ...prev, ...emails ])));
    which==="leads"? setCcAllLeads(true) : setCcAllPMs(true);
  }

  async function send(){
    if (!picked.length) return alert("Pick at least one recipient");
    const ccList = cc.split(",").map(x=>x.trim()).filter(Boolean);
    setBusy(true);
    try{
      await fetch(`/api/stages/request_signoff_batch?project_id=${projectId}`, {
        method:"POST", credentials:"include", headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          stage_id: stageId, emails: picked, cc: ccList,
          cc_all_leads: ccAllLeads, cc_all_pms: ccAllPMs,
          title: stageTitle, area, message: msg })
      });
      // remember last
      localStorage.setItem(storeKey, JSON.stringify({ emails:picked, cc, area, message:msg, ccAllLeads, ccAllPMs }));
      onClose(); alert(`Request sent to ${picked.length} recipient(s)`);
    }catch(e:any){ alert(String(e?.message||e)); setBusy(false); }
  }

  return (
    <div className="fixed inset-0 bg-black/40 z-[200]" onClick={onClose}>
      <div className="mx-auto mt-[8vh] w-[720px] max-w-[96%] bg-white dark:bg-neutral-900 rounded shadow-xl border"
           onClick={e=>e.stopPropagation()}>
        <div className="p-3 border-b">
          <div className="text-sm font-medium">Request Sign-Off</div>
          <div className="text-xs text-muted-foreground">{stageTitle}{stageArea?` • ${stageArea}`:""}</div>
        </div>
        <div className="p-3 space-y-2">
          <div className="flex items-center gap-2">
            <input ref={inputRef} className="border rounded p-2 w-full text-sm"
                   placeholder="Search recipients (email or role)…" value={q} onChange={e=>setQ(e.target.value)} />
            <select className="border rounded p-2 text-sm" value={area} onChange={e=>setArea(e.target.value)}>
              <option value="">All areas</option>
              {DEFAULT_AREAS.map(a=> <option key={a} value={a}>{a}</option>)}
            </select>
          </div>

          <div className="flex items-center gap-2 text-xs">
            <button className="brand-btn text-xs" onClick={()=>applyPreset("leads")}>+ Leads</button>
            <button className="brand-btn text-xs" onClick={()=>applyPreset("pms")}>+ PMs</button>
          </div>

          <div className="max-h-[36vh] overflow-auto border rounded">
            {hits.map(h=>(
              <label key={h.email} className="flex items-center gap-2 px-2 py-1 hover:bg-black/5 dark:hover:bg-white/5">
                <input type="checkbox" checked={picked.includes(h.email)} onChange={()=>toggle(h.email)} />
                <span className="text-sm">{h.email}</span>
                <span className="text-[11px] text-muted-foreground ml-auto">
                  {h.role || ""} {h.can_sign_all ? "• signer(all)" : h.sign_areas?.length ? `• signer(${h.sign_areas.join(",")})`:""}
                </span>
                {!h.allowed && area && <span className="text-[11px] text-red-500 ml-1">(area mismatch)</span>}
              </label>
            ))}
            {!hits.length && <div className="p-2 text-xs text-muted-foreground">No matches</div>}
          </div>

          <div className="grid md:grid-cols-2 gap-2">
            <input className="border rounded p-2 text-sm" placeholder="CC (comma-separated)" value={cc} onChange={e=>setCc(e.target.value)} />
            <div className="flex items-center gap-2 text-xs">
              <label className="flex items-center gap-1"><input type="checkbox" checked={ccAllLeads} onChange={e=>setCcAllLeads(e.target.checked)}/> CC all leads</label>
              <label className="flex items-center gap-1"><input type="checkbox" checked={ccAllPMs} onChange={e=>setCcAllPMs(e.target.checked)}/> CC all PMs</label>
            </div>
          </div>
          <textarea className="border rounded p-2 w-full text-sm" rows={3}
                    placeholder="Optional message…" value={msg} onChange={e=>setMsg(e.target.value)} />
        </div>
        <div className="p-3 border-t flex justify-end gap-2">
          <button className="brand-btn text-xs" onClick={onClose}>Cancel</button>
          <button className="brand-btn text-xs swoosh" onClick={send} disabled={busy || picked.length===0}>
            {busy?"Sending…":`Send (${picked.length})`}
          </button>
        </div>
      </div>
    </div>
  );
}


(Your timeline button already pops this modal.)

2) Stage Editor — combined undo (Revert last)

Patch client/src/pages/Stages.tsx

Add transaction stack per stage & a small row toolbar:

const [txStack,setTxStack] = useState<Record<string,{start_date?:string;end_date?:string}[]>>({});

function pushTx(id:string, prev:{start_date?:string; end_date?:string}){
  setTxStack(s => ({...s, [id]: [...(s[id]||[]), prev]}));
}
function popTx(id:string){
  const arr = txStack[id]||[]; if (!arr.length) return null;
  const prev = arr[arr.length-1];
  setTxStack(s => ({...s, [id]: arr.slice(0, -1)}));
  return prev;
}

async function revertLast(id:string){
  const prev = popTx(id); if (!prev) return;
  await saveField(id, prev);
  toast({ title:"Reverted", description:"Stage dates restored" });
}

// When start/end changes, call pushTx before first change:
function ensureTxPush(id:string){
  // push only once per edit session; simplest approach: always push previous pair
  pushTx(id, { start_date: s.start_date, end_date: s.end_date });
}


Add a row toolbar (right side of each row):

<div className="flex items-center justify-end gap-2">
  <button className="brand-btn text-xs" onClick={()=>revertLast(s.id)} disabled={!(txStack[s.id]||[]).length}>Revert last</button>
</div>


Make sure when you change start_date or end_date, you call ensureTxPush(s.id) before applying and then proceed with the sync/save logic from v2.12. (If you already call pushUndo, you can harmonize pushTx for both fields.)

3) Digest links open filter panels

You already added anchor scroll. Add filter-open logic:

client/src/pages/ActionsList.tsx

const params = new URLSearchParams((loc.hash || "").replace(/^#/, ""));
const openFilters = params.get("openFilters")==="1";
useEffect(()=>{
  if (openFilters) setFiltersOpen(true);
},[openFilters]);


client/src/pages/AdminAuditTimeline.tsx

const params = new URLSearchParams((loc.hash || "").replace(/^#/, ""));
const openFilters = params.get("openFilters")==="1";
const tab = params.get("tab"); // "risks" | "decisions" | ...
useEffect(()=>{
  if (openFilters) setFiltersOpen(true);
  if (tab) setActiveTab(tab); // whatever state your tabs use
},[openFilters, tab]);


You can now generate digest links like:

/projects/:pid/actions/list#openFilters=1&id=<actionId>
/projects/:pid/admin/audit-timeline#openFilters=1&tab=risks&id=<riskId>

4) Wellness Admin — responders trend line + CSV
4A) Backend trend endpoint (overall responders per day)

server/routers/wellness_responders_trend.py (new)

from fastapi import APIRouter, Depends, Query
from datetime import datetime, timedelta, timezone
from ..tenant import TenantCtx
from ..guards import require_role
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/wellness", tags=["wellness"])

@router.get("/responders_trend")
def responders_trend(project_id: str = Query(...), days: int = 30,
                     ctx: TenantCtx = Depends(require_role({"owner","admin","pm"}))):
    sb = get_user_supabase(ctx)
    end = datetime.now(timezone.utc).date()
    days = 7 if days==7 else 30
    start = end - timedelta(days=days-1)
    try:
        rows = sb.table("team_wellness").select("user_id,created_at")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id)\
               .gte("created_at", start.isoformat()).execute().data or []
    except Exception:
        rows = []
    # total checkins per day
    by = {}
    for r in rows:
        d = (r.get("created_at") or "")[:10]
        if not d: continue
        by[d] = by.get(d,0) + 1
    out=[]
    for i in range(days):
        day = (start + timedelta(days=i)).isoformat()
        out.append({"date": day, "count": by.get(day,0)})
    return {"items": out}


CSV of top responders (existing delta endpoint already returns items; quick CSV):

server/routers/wellness_top_export.py (new)

from fastapi import APIRouter, Depends, Query
from fastapi.responses import StreamingResponse
import io, csv
from ..tenant import TenantCtx
from ..guards import require_role
from ..deps import get_user_supabase
from .wellness_rollup import top_responders

router = APIRouter(prefix="/api/wellness", tags=["wellness"])

@router.get("/top_responders.csv")
def top_export(project_id: str = Query(...), days: int = 30, ctx: TenantCtx = Depends(require_role({"owner","admin","pm"}))):
    sb = get_user_supabase(ctx)  # not used directly—just ensures auth
    # reuse the endpoint:
    from fastapi.testclient import TestClient
    # In your codebase, call the function directly instead of TestClient; quick hack:
    items = top_responders(project_id, days, ctx)["items"] if callable(top_responders) else []
    s = io.StringIO(); w = csv.writer(s); w.writerow(["user_id","checkins","delta"])
    for r in items: w.writerow([r.get("user_id"), r.get("checkins"), r.get("delta",0)])
    s.seek(0)
    return StreamingResponse(iter([s.read()]), media_type="text/csv",
      headers={"Content-Disposition": 'attachment; filename="top_responders.csv"'})


Mount in server/main.py:

from .routers import wellness_responders_trend, wellness_top_export
app.include_router(wellness_responders_trend.router)
app.include_router(wellness_top_export.router)

4B) Frontend: tiny trend line component + buttons

client/src/components/AdminWellnessTrend.tsx (new)

import { useEffect, useState } from "react";
import { getJSON } from "@/lib/authFetch";
import { useParams } from "react-router-dom";

export default function AdminWellnessTrend({ days }:{ days:7|30 }){
  const { projectId } = useParams();
  const [data,setData]=useState<{date:string;count:number}[]>([]);
  useEffect(()=>{ (async()=>{
    try{ const d = await getJSON(`/api/wellness/responders_trend?project_id=${projectId}&days=${days}`); setData(d.items||[]); }
    catch{ setData([]); }
  })(); },[projectId, days]);

  // simple SVG line
  const max = Math.max(1, ...data.map(d=>d.count));
  const pts = data.map((d,i)=> `${(i/(data.length-1))*100},${100 - (d.count/max)*100}`).join(" ");

  return (
    <div className="brand-card p-3">
      <div className="text-sm font-medium mb-1">Responders Trend (last {days}d)</div>
      <svg viewBox="0 0 100 100" className="w-full h-[120px]">
        <polyline fill="none" stroke="var(--brand-accent)" strokeWidth="1.5" points={pts} />
      </svg>
    </div>
  );
}


Add to Admin Health/Ops next to the wellness chart:

import AdminWellnessTrend from "@/components/AdminWellnessTrend";
// ...
<div className="grid md:grid-cols-2 gap-3">
  <AdminWellnessTrend days={7}/>
  <AdminWellnessTrend days={30}/>
</div>


Add a button where you list Top Responders:

<button className="brand-btn text-xs" onClick={()=> downloadGET(`/api/wellness/top_responders.csv?project_id=${projectId}&days=${range}`, "top_responders.csv")}>
  Export Top Responders
</button>

5) 90-second validation

Request Sign-Off modal: global search + area filter chips, CC all Leads/PMs, remembers last recipients per stage

Stage Editor: Revert last restores the prior start/end pair; duration preserved either direction with keyboard

Digest links: Views open with filters visible and scroll to row

Wellness Admin: trend line for last 7/30 days; Top Responders CSV; per-user modal with sparkline smoothing + date range