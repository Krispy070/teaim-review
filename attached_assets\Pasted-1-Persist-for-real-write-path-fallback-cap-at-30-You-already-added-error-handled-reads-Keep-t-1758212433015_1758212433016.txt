1) Persist for real (write-path fallback + cap at 30)

You already added error-handled reads. Keep that—and add a psycopg write fallback so “set/add areas” work even if PostgREST is grumpy. Minimal patch to your existing /workstreams/set and /workstreams/add:

# /server/main.py (add near your other imports)
from .db import get_conn

def _ws_upsert_psycopg(org_id, project_id, items):
    with get_conn() as conn, conn.cursor() as cur:
        # Soft-inactivate existing
        cur.execute("update workstreams set is_active=false where org_id=%s and project_id=%s",
                    (org_id, project_id))
        # Insert fresh actives (keep up to 30)
        for i,it in enumerate(items[:30]):
            cur.execute("""
              insert into workstreams (org_id, project_id, name, description, sort_order, is_active)
              values (%s,%s,%s,%s,%s,true)
            """, (org_id, project_id, it.get("name","")[:120], it.get("description","") or "", it.get("sort_order", i)))

@app.post("/workstreams/set")
def set_workstreams(org_id: str = Body(...), project_id: str = Body(...),
                    items: list[dict] = Body(...)):
    if len(items) > 30:
        return {"ok": False, "error": "Max 30 functional areas"}
    try:
        # try REST path first
        sb.table("workstreams").update({"is_active": False}).eq("org_id", org_id).eq("project_id", project_id).execute()
        for i,it in enumerate(items):
            sb.table("workstreams").insert({
              "org_id": org_id, "project_id": project_id,
              "name": it.get("name","")[:120], "description": it.get("description","") or "",
              "sort_order": it.get("sort_order", i), "is_active": True
            }).execute()
        return {"ok": True, "count": len(items), "via": "rest"}
    except Exception:
        _ws_upsert_psycopg(org_id, project_id, items)
        return {"ok": True, "count": len(items), "via": "psycopg"}

@app.post("/workstreams/add")
def add_workstream(org_id: str = Body(...), project_id: str = Body(...),
                   name: str = Body(...), description: Optional[str] = Body(None),
                   sort_order: int = Body(0)):
    try:
        active = sb.table("workstreams").select("id", count="exact")\
            .eq("org_id", org_id).eq("project_id", project_id).eq("is_active", True).execute()
        if (active.count or 0) >= 30:
            return {"ok": False, "error": "Max 30 functional areas"}
        sb.table("workstreams").insert({
          "org_id": org_id, "project_id": project_id,
          "name": name[:120], "description": description or "", "sort_order": sort_order, "is_active": True
        }).execute()
        return {"ok": True, "via": "rest"}
    except Exception:
        _ws_upsert_psycopg(org_id, project_id, [{"name": name, "description": description, "sort_order": sort_order}])
        return {"ok": True, "via": "psycopg"}


This gives you durable writes no matter what.

2) Make it SOW-driven end-to-end

When a SOW is ingested, run a bootstrap once so the grid auto-populates:

# /server/main.py inside your /ingest or /ingest-sync background path
try:
    if file.filename.lower().startswith("sow") or "statement of work" in (text[:300].lower()):
        # call your bootstrap endpoint directly (without HTTP)
        CANDIDATES = ["HCM","Recruiting","Talent","Compensation","Benefits","Time & Absence",
                      "Payroll","Finance","Projects","Procurement","Expenses",
                      "Security","Integrations","Reporting/Prism","Change Management",
                      "Training","Cutover","Data Conversion","Testing"]
        found = [{"name": c} for c in CANDIDATES if c.split("&")[0].split("/")[0].strip().lower() in text.lower()]
        if not found:
            found = [{"name": n} for n in ["HCM","Payroll","Finance","Integrations","Security","Reporting","Cutover"]]
        # persist with fallback
        _ws_upsert_psycopg(org_id, project_id, found[:30])
except Exception:
    pass


Result: the first time you drop a SOW, Functional Areas fills itself (up to 30). You can refine extraction later with an LLM.

3) Frontend: cap, manage, and show descriptions

You already render Functional Areas. Add a light admin affordance (PM-only) to update the list live:

// inside FunctionalAreas component
const [editing, setEditing] = useState(false);
const [draft, setDraft] = useState<any[]>([]);

async function loadAreas(){
  const js = await getJSON("/workstreams", { org_id: orgId, project_id: projectId });
  setAreas(js.items || []);
}
useEffect(()=>{ if(orgId&&projectId) loadAreas(); }, [orgId, projectId]);

async function saveAreas(){
  await fetch("/api/workstreams/set", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ org_id: orgId, project_id: projectId, items: draft })
  });
  setEditing(false);
  loadAreas();
}

// admin controls (show if PM/Admin)
{isPM && (
  <div className="flex gap-2">
    <button className="text-xs px-2 py-1 border rounded" onClick={()=>{ setDraft(areas); setEditing(true); }}>
      Edit Areas
    </button>
  </div>
)}
{editing && (
  <div className="mt-3 p-3 border rounded-xl">
    <div className="text-sm mb-2">Up to 30 areas. Drag to reorder; edit names/descriptions.</div>
    {draft.map((it,idx)=>(
      <div key={idx} className="flex gap-2 items-center mb-1">
        <input className="border px-2 py-1 text-sm w-52" value={it.name}
               onChange={e=>{ const d=[...draft]; d[idx].name=e.target.value; setDraft(d); }} />
        <input className="border px-2 py-1 text-sm flex-1" placeholder="description"
               value={it.description||""}
               onChange={e=>{ const d=[...draft]; d[idx].description=e.target.value; setDraft(d); }} />
        <button className="text-xs px-2 py-1 border rounded"
                onClick={()=>{ const d=[...draft]; d.splice(idx,1); setDraft(d); }}>
          Remove
        </button>
      </div>
    ))}
    <div className="flex gap-2 mt-2">
      <button className="text-xs px-2 py-1 border rounded" onClick={()=> setDraft([...draft, {name:"New Area"}])}>
        + Add Area
      </button>
      <div className="text-xs text-slate-500">{draft.length}/30</div>
      <div className="flex-1" />
      <button className="text-xs px-3 py-1 border rounded" onClick={()=>setEditing(false)}>Cancel</button>
      <button className="text-xs px-3 py-1 border rounded bg-sky-600 text-white" onClick={saveAreas}>Save</button>
    </div>
  </div>
)}


(You can add drag-n-drop later; this gets you clean add/remove/edit with the 30 cap visible.)

Smoke tests (copy/paste)
Seed areas via API (instant demo)
BASE="http://localhost:5000/api"
ORG="d915376c-2bd7-4e79-b9c9-aab9d7fcb5a8"
PROJ="dced0b98-87b4-46ff-b2a4-2cf8e627e8d2"

curl -s -X POST "$BASE/workstreams/set" -H "Content-Type: application/json" -d @- <<JSON
{"org_id":"$ORG","project_id":"$PROJ","items":[
  {"name":"HCM","description":"Core HR & business processes"},
  {"name":"Recruiting"},{"name":"Talent"},{"name":"Compensation"},
  {"name":"Benefits"},{"name":"Time & Absence"},{"name":"Payroll"},
  {"name":"Finance"},{"name":"Projects"},{"name":"Procurement"},
  {"name":"Expenses"},{"name":"Security"},{"name":"Integrations"},
  {"name":"Reporting/Prism"},{"name":"Cutover"}
]}
JSON


Refresh the dashboard → Functional Areas shows the new list (count label updates, tooltips show descriptions).

Bootstrap via SOW (optional)

Upload a SOW with /api/ingest-sync and confirm the areas populate automatically.

Why this hits the brief

SOW-driven: areas extract from SOW; PM can edit anytime.

Scalable: up to 30; sort order preserved.

Resilient: REST first, psycopg fallback; no demo-breakers.

Live UI: dashboard shows real areas (health/overdue wired as you enrich Actions/Summaries).

If anything throws an error while you paste, send me the line and I’ll patch it on the spot. After this, we’ll wire Email Dropbox and Auth—and you’ll have a killer, live demo where uploads instantly move the dashboard.