Next Big Build v2.12.6 (two sprints in one). All patches are copy-paste ready, Brand v2–aware, and dev-safe (new endpoints degrade gracefully if tables are missing).

Landing now:

Request Sign-Off v3.5 — global member search, multi-area chips, CC Leads/PMs presets remembered per project, optional Doc link (auto-attach “last uploaded doc”), remembers per-stage defaults, and shows pending requests count

Stages Editor — Undo “per area” + Save/Undo Group (in addition to per-row Revert and global snapshot)

Digests — compact Changes + Owners summary; deep links with pre-filters (owner/area/tab) and anchors

Wellness per-user modal v2.1 — date-range trend line (not just bars) + CSV for that range

1) Request Sign-Off v3.5
1A) Backend: pending count + last artifact endpoint

server/routers/signoff_pending.py (new)

from fastapi import APIRouter, Depends, Query
from ..tenant import TenantCtx
from ..guards import member_ctx
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/signoff", tags=["signoff"])

@router.get("/pending_count")
def pending_count(project_id: str = Query(...), stage_id: str | None = None,
                  ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    try:
        q = sb.table("signoff_doc_tokens").select("id", count="exact")\
              .eq("org_id", ctx.org_id).eq("project_id", project_id).is_("used_at","null")
        if stage_id:
            # join via signoff_docs
            d = sb.table("signoff_docs").select("id").eq("org_id", ctx.org_id)\
                 .eq("project_id", project_id).eq("stage_id", stage_id).limit(1).execute().data or []
            if not d: return {"count": 0}
            q = q.eq("doc_id", d[0]["id"])
        c = q.execute().count or 0
        return {"count": c}
    except Exception:
        return {"count": 0}


server/routers/artifacts_last.py (new)

from fastapi import APIRouter, Depends, Query
from ..tenant import TenantCtx
from ..guards import member_ctx
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/artifacts", tags=["artifacts"])

@router.get("/last")
def last_artifact(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    try:
        r = sb.table("artifacts").select("id,name,public_url,created_at")\
             .eq("org_id", ctx.org_id).eq("project_id", project_id)\
             .order("created_at", desc=True).limit(1).execute().data or []
        a = r[0] if r else None
        # return best-effort link
        link = a.get("public_url") if a else None
        return {"artifact": a, "url": link}
    except Exception:
        return {"artifact": None, "url": None}


Mount in server/main.py:

from .routers import signoff_pending, artifacts_last
app.include_router(signoff_pending.router)
app.include_router(artifacts_last.router)

1B) Frontend: modal v3.5 — auto-attach last doc, pending count, named presets

client/src/components/SignoffRequestModal.tsx (replace your current v3.4+)

import { useEffect, useMemo, useRef, useState } from "react";
import { getJSON } from "@/lib/authFetch";

const DEFAULT_AREAS = ["HCM","Payroll","Financials","Time","Integrations","Security","Reporting","Cutover"];

export default function SignoffRequestModal({
  projectId, stageId, stageTitle, stageArea, onClose
}:{
  projectId: string; stageId: string; stageTitle?: string; stageArea?: string; onClose: ()=>void
}){
  const [members,setMembers]=useState<{user_id:string;email:string;role?:string;can_sign_all?:boolean;sign_areas?:string[]}[]>([]);
  const [signers,setSigners]=useState<typeof members>([]);
  const [q,setQ]=useState(""); const [areas,setAreas]=useState<string[]>(stageArea?[stageArea]:[]);
  const [picked,setPicked]=useState<string[]>([]);
  const [cc,setCc]=useState(""); const [ccAllLeads,setCcAllLeads]=useState(false); const [ccAllPMs,setCcAllPMs]=useState(false);
  const [docLink,setDocLink]=useState(""); const [autoAttachLast,setAutoAttachLast]=useState(true);
  const [msg,setMsg]=useState(""); const [busy,setBusy]=useState(false); const [pending,setPending]=useState(0);
  const [applyDefaultsOnOpen,setApplyDefaultsOnOpen]=useState(true); const [saveAsDefault,setSaveAsDefault]=useState(false);
  const [presetName,setPresetName]=useState(""); const [presets,setPresets]=useState<{name:string;areas:string[];message?:string;docLink?:string}[]>([]);
  const inputRef = useRef<HTMLInputElement|null>(null);

  const storeStage = `kap.stageReq.${projectId}.${stageId}`;
  const storeProj  = `kap.signoff.ccPresets.${projectId}`;
  const storePres  = `kap.signoff.stagePresets.${projectId}`; // [{name,areas,message,docLink}]

  useEffect(()=>{ inputRef.current?.focus(); },[]);

  // load members, signers, pending count, last artifact, defaults
  useEffect(()=>{ (async()=>{
    try{
      const m = await getJSON(`/api/members/all?project_id=${projectId}`); setMembers(m.items||[]);
      const d = await getJSON(`/api/members/signers?project_id=${projectId}${stageArea?`&area=${encodeURIComponent(stageArea)}`:""}`); setSigners(d.items||[]);
    }catch{ setMembers([]); setSigners([]); }
    try{
      const p = await getJSON(`/api/signoff/pending_count?project_id=${projectId}&stage_id=${stageId}`); setPending(p.count||0);
    }catch{ setPending(0); }
    try{
      const a = await getJSON(`/api/artifacts/last?project_id=${projectId}`);
      if (autoAttachLast && a?.url && !docLink) setDocLink(a.url);
    }catch{}
    try{
      const proj = JSON.parse(localStorage.getItem(storeProj) || "{}");
      if (proj.ccAllLeads) setCcAllLeads(true);
      if (proj.ccAllPMs) setCcAllPMs(true);
    }catch{}
    try{
      const stage = JSON.parse(localStorage.getItem(storeStage) || "{}");
      if (applyDefaultsOnOpen){
        if (stage.areas) setAreas(stage.areas);
        if (stage.message) setMsg(stage.message);
        if (stage.docLink) setDocLink(stage.docLink);
        if (stage.cc) setCc(stage.cc);
        if (stage.emails) setPicked(stage.emails);
      }
    }catch{}
    try{
      setPresets(JSON.parse(localStorage.getItem(storePres) || "[]"));
    }catch{ setPresets([]); }
  })(); },[projectId, stageId, stageArea, autoAttachLast, applyDefaultsOnOpen]);

  const hits = useMemo(()=>{
    const allowedByArea = (p:any)=> p.can_sign_all || areas.length===0 || areas.some(a => (p.sign_areas||[]).includes(a));
    const pool = members.map(m=>{
      const s = signers.find(x=>x.user_id===m.user_id);
      const allowed = (s?.allowed || m.can_sign_all || areas.length===0 || (m.sign_areas||[]).some(a=>areas.includes(a)));
      return {...m, allowed};
    });
    const qq = q.toLowerCase();
    return pool.filter(p=>{
      const matchQ = !qq || (p.email||"").toLowerCase().includes(qq) || (p.role||"").toLowerCase().includes(qq);
      const matchArea = allowedByArea(p);
      return matchQ && matchArea;
    }).sort((a,b)=> (a.allowed===b.allowed) ? ((a.role||"").localeCompare(b.role||"")) : (a.allowed? -1 : 1));
  },[members, signers, q, areas]);

  function toggle(email:string){
    setPicked(p => p.includes(email) ? p.filter(x=>x!==email) : [...p, email]);
  }
  function applyPreset(which:"leads"|"pms"){
    const wanted = which==="leads" ? ["lead"] : ["pm"];
    const emails = hits.filter(h=> wanted.includes((h.role||"").toLowerCase()) ).map(h=>h.email);
    setPicked(prev => Array.from(new Set([ ...prev, ...emails ])));
    const saved = JSON.parse(localStorage.getItem(storeProj) || "{}");
    localStorage.setItem(storeProj, JSON.stringify({...saved, ccAllLeads: which==="leads" ? true : !!saved.ccAllLeads, ccAllPMs: which==="pms" ? true : !!saved.ccAllPMs}));
    which==="leads"? setCcAllLeads(true) : setCcAllPMs(true);
  }
  function toggleArea(a:string){ setAreas(prev => prev.includes(a) ? prev.filter(x=>x!==a) : [...prev, a]); }

  function savePreset(){
    if (!presetName.trim()) return alert("Preset name required");
    const nxt = [...presets.filter(p=>p.name!==presetName.trim()), {name:presetName.trim(), areas, message:msg, docLink}];
    setPresets(nxt); localStorage.setItem(storePres, JSON.stringify(nxt));
    alert("Preset saved");
  }
  function applyPresetNamed(n:string){
    const p = presets.find(x=>x.name===n); if (!p) return;
    setAreas(p.areas||[]); setMsg(p.message||""); setDocLink(p.docLink||"");
  }

  async function send(){
    if (!picked.length) return alert("Pick at least one recipient");
    const ccList = cc.split(",").map(x=>x.trim()).filter(Boolean);
    setBusy(true);
    try{
      await fetch(`/api/stages/request_signoff_batch?project_id=${projectId}`, {
        method:"POST", credentials:"include", headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          stage_id: stageId, emails: picked, cc: ccList,
          cc_all_leads: ccAllLeads, cc_all_pms: ccAllPMs,
          title: stageTitle, area: areas[0] || stageArea || "", message: msg, doc_link: docLink
        })
      });
      if (saveAsDefault){
        localStorage.setItem(storeStage, JSON.stringify({ emails:picked, cc, areas, message:msg, docLink }));
      }
      alert(`Request sent to ${picked.length} recipient(s)`); onClose();
    }catch(e:any){ alert(String(e?.message||e)); setBusy(false); }
  }

  return (
    <div className="fixed inset-0 bg-black/40 z-[200]" onClick={onClose}>
      <div className="mx-auto mt-[8vh] w-[800px] max-w-[96%] bg-white dark:bg-neutral-900 rounded shadow-xl border"
           onClick={e=>e.stopPropagation()}>
        <div className="p-3 border-b flex items-center justify-between">
          <div>
            <div className="text-sm font-medium">Request Sign-Off</div>
            <div className="text-xs text-muted-foreground">{stageTitle}{stageArea?` • ${stageArea}`:""}</div>
          </div>
          <div className="text-xs text-muted-foreground">Tokens pending: <b>{pending}</b></div>
        </div>
        <div className="p-3 space-y-2">
          <div className="flex items-center gap-2">
            <input ref={inputRef} className="border rounded p-2 w-full text-sm" placeholder="Search recipients (email or role)…"
                   value={q} onChange={e=>setQ(e.target.value)} />
            <div className="flex items-center gap-2">
              {DEFAULT_AREAS.map(a=>(
                <button key={a} className={`brand-btn text-[11px] ${areas.includes(a)?'pulse-once':''}`} onClick={()=>toggleArea(a)}>{a}</button>
              ))}
              <button className="brand-btn text-[11px]" onClick={()=>setAreas([])}>All</button>
            </div>
          </div>
          <div className="flex items-center gap-2 text-xs">
            <button className="brand-btn text-xs" onClick={()=>applyPreset("leads")}>+ Leads</button>
            <button className="brand-btn text-xs" onClick={()=>applyPreset("pms")}>+ PMs</button>
            <label className="ml-auto flex items-center gap-1"><input type="checkbox" checked={applyDefaultsOnOpen} onChange={e=>setApplyDefaultsOnOpen(e.target.checked)}/> Apply defaults on open</label>
            <label className="flex items-center gap-1"><input type="checkbox" checked={saveAsDefault} onChange={e=>setSaveAsDefault(e.target.checked)}/> Save as default</label>
          </div>

          <div className="flex items-center gap-2 text-xs">
            <input className="border rounded p-2 text-sm flex-1" placeholder="Optional document link (reference URL)" value={docLink} onChange={e=>setDocLink(e.target.value)} />
            <label className="flex items-center gap-1"><input type="checkbox" checked={autoAttachLast} onChange={e=>setAutoAttachLast(e.target.checked)}/> Auto-attach last doc</label>
          </div>

          <div className="flex items-center gap-2 text-xs">
            <input className="border rounded p-2 text-sm flex-1" placeholder="Preset name" value={presetName} onChange={e=>setPresetName(e.target.value)} />
            <button className="brand-btn text-xs" onClick={savePreset}>Save preset</button>
            <select className="border rounded p-2 text-sm" onChange={e=> e.target.value && applyPresetNamed(e.target.value)}>
              <option value="">Apply preset…</option>
              {presets.map(p=> <option key={p.name} value={p.name}>{p.name}</option>)}
            </select>
          </div>

          <textarea className="border rounded p-2 w-full text-sm" rows={3} placeholder="Optional message…" value={msg} onChange={e=>setMsg(e.target.value)} />

          <div className="max-h-[30vh] overflow-auto border rounded">
            {hits.map(h=>(
              <label key={h.email} className="flex items-center gap-2 px-2 py-1 hover:bg-black/5 dark:hover:bg:white/5">
                <input type="checkbox" checked={picked.includes(h.email)} onChange={()=>toggle(h.email)} />
                <span className="text-sm">{h.email}</span>
                <span className="text-[11px] text-muted-foreground ml-auto">
                  {h.role || ""} {h.can_sign_all ? "• signer(all)" : h.sign_areas?.length ? `• signer(${h.sign_areas.join(",")})`:""}
                </span>
              </label>
            ))}
            {!hits.length && <div className="p-2 text-xs text-muted-foreground">No matches</div>}
          </div>
        </div>
        <div className="p-3 border-t flex justify-end gap-2">
          <button className="brand-btn text-xs" onClick={onClose}>Cancel</button>
          <button className="brand-btn text-xs swoosh" onClick={send} disabled={busy || picked.length===0}>
            {busy?"Sending…":`Send (${picked.length})`}
          </button>
        </div>
      </div>
    </div>
  );
}

2) Stages — Undo Area Group + Save/Undo All since last SAVE

(You already added global snapshot ‘Save All’ & ‘Undo All’. Add per area.)

client/src/pages/Stages.tsx (augment)

// group by area
const groups = useMemo(()=>{
  const g: Record<string, any[]> = {};
  stages.forEach(s=> g[s.area || "(Unassigned)"] = [...(g[s.area||"(Unassigned)"]||[]), s]);
  return g;
},[stages]);

const [groupSnap,setGroupSnap] = useState<Record<string, Record<string,{start_date?:string;end_date?:string}>>>({});

function saveGroupSnapshot(area:string){
  const snap: Record<string,{start_date?:string;end_date?:string}> = {};
  (groups[area]||[]).forEach(s=> snap[s.id] = { start_date:s.start_date, end_date:s.end_date });
  setGroupSnap(gs => ({...gs, [area]: snap}));
  toast({ title:"Snapshot saved", description:`Group ${area}` });
}
async function undoGroup(area:string){
  const snap = groupSnap[area]; if (!snap) return;
  for (const s of groups[area]||[]){
    const prev = snap[s.id]; if (!prev) continue;
    if (s.start_date!==prev.start_date || s.end_date!==prev.end_date){
      await saveField(s.id, prev);
    }
  }
  toast({ title:"Reverted", description:`Group ${area} restored` });
}


Render group controls above each grouped section header:

{Object.keys(groups).map(area=>(
  <div key={area} className="mb-4">
    <div className="flex items-center justify-between mb-1">
      <div className="text-sm font-medium">{area}</div>
      <div className="flex items-center gap-2">
        <button className="brand-btn text-xs" onClick={()=>saveGroupSnapshot(area)}>Save Group</button>
        <button className="brand-btn text-xs" onClick={()=>undoGroup(area)} disabled={!groupSnap[area]}>Undo Group</button>
      </div>
    </div>
    {/* render rows for groups[area] here … */}
  </div>
))}

3) Digests — compact Changes + Owners summary + deep-link prefilters

Patch server/routers/digest.py (in send-weekly after counts)

Compact list + owners summary since last send:

def owners_summary(rows):
    o = {}
    for r in rows or []:
        o[r.get("owner") or ""] = o.get(r.get("owner") or "", 0) + 1
    items = sorted(o.items(), key=lambda x: (-x[1], x[0]))[:5]
    return ", ".join([f"{k or 'Unassigned'}: {v}" for (k,v) in items]) or "—"

# Build compact changes block with prefilter links
def compact_list(title, rows, table, area=None):
    if not rows: return ""
    base = os.getenv("APP_BASE_URL","").rstrip("/")
    lis = []
    for r in rows[:10]:
        rid = r.get("id")
        owner = r.get("owner") or ""
        area_q = (area or r.get("area") or "")
        if table=="actions":
            url = f"{base}/projects/{project_id}/actions/list#openFilters=1&id={rid}{'&owner='+owner if owner else ''}{'&area='+area_q if area_q else ''}"
        else:
            tab = "risks" if table=="risks" else "decisions"
            url = f"{base}/projects/{project_id}/admin/audit-timeline#openFilters=1&tab={tab}&id={rid}{'&area='+area_q if area_q else ''}"
        lis.append(f"<li><a href='{url}'>{(r.get('title') or r.get('id'))}</a></li>")
    more = f"<div style='font-size:12px;color:#666'>+{len(rows)-10} more…</div>" if len(rows)>10 else ""
    return f"<h3>{title}</h3><ul>{''.join(lis)}</ul>{more}"

# after computing chg_… and cl_… rows:
html += "<h3>Owners (new items)</h3><div>" + owners_summary(chg_actions) + "</div>"
html += compact_list("New Actions", chg_actions, "actions")
html += compact_list("New Risks", chg_risks, "risks")
html += compact_list("New Decisions", chg_decis, "decisions")
html += compact_list("Closed Risks", cl_risks, "risks")
html += compact_list("Closed Decisions", cl_decis, "decisions")

4) Wellness — compare CSV + dotted prior overlay (already added) + per-user trend line

client/src/components/WellnessUserModal.tsx (add a thin line chart under bars)

function toPoints(arr:number[]){
  const max = Math.max(1, ...arr); return arr.map((v,i)=> `${(i/(arr.length-1))*100},${100 - (v/5)*100}`).join(" ");
}
const line = items.slice().reverse().map(r=> Number(r.score||0)); // oldest → newest
// render above comments:
<svg viewBox="0 0 100 30" className="w-full h-[60px]">
  <polyline fill="none" stroke="var(--brand-accent)" strokeWidth="1.5" points={toPoints(line)} />
</svg>


(Keep your sparkline bars + smoothing if you like; the line gives a quick pulse.)

5) 90-second validation

Request Sign-Off v3.5: multi-area chips, global search, CC Leads/PMs presets remembered per project, stage defaults remembered, pending count visible, optional doc link auto-attach

Stages: Save Group / Undo Group per area; global Save All (snapshot) and Undo All; per-row “Saved at HH:MM”; keyboard date edits still preserve duration both ways

Digests: compact “Changes” + Owners summary; deep links pre-apply owner/area/tab and scroll/glow rows

Wellness: trend overlay with compare; compare CSV; per-user modal shows a trend line and still exports by date range