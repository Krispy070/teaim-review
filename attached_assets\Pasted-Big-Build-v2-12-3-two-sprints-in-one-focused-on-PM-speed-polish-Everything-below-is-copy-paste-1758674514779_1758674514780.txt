Big Build v2.12.3 (two sprints in one), focused on PM speed & polish. Everything below is copy-paste ready, Brand v2–aware, and dev-safe (every new endpoint fails gracefully if a table is missing).

What lands now:

Request Sign-Off v3.3 → global member search, area chips, CC all Leads/PMs, optional message, remembers last recipients per stage

Stages Editor date v2 → duration-preserve both ways and combined undo (“Revert last”) with toast

Digests → deep links that open filter panels & scroll to row on Actions List & Audit Timeline

Wellness Admin → responders trend line w/ moving-average; Top Responders CSV; per-user modal sparkline & date range export

1) Request Sign-Off v3.3 (global search, CC presets, remember last)
1A) Backend — CC PMs in addition to leads

server/routers/stages_request_sign.py (extend your existing file)

from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime, timezone, timedelta
import os

from ..tenant import TenantCtx
from ..guards import require_role
from ..deps import get_user_supabase, get_service_supabase
from ..routers.signoff_docs_gen import DraftReq

router = APIRouter(prefix="/api/stages", tags=["stages"])
PM_PLUS = require_role({"owner","admin","pm"})

class RequestBatch(BaseModel):
    stage_id: str
    emails: List[str] = Field(min_items=1)
    cc: Optional[List[str]] = None
    cc_all_leads: bool = False
    cc_all_pms: bool = False     # NEW
    title: Optional[str] = "Stage Sign-Off"
    area: Optional[str] = None
    message: Optional[str] = None
    expires_hours: int = 120

@router.post("/request_signoff_batch")
def request_signoff_batch(body: RequestBatch, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx); sbs = get_service_supabase()

    # 1) Find or create sign-off doc for this stage
    doc = sbs.table("signoff_docs").select("id,status").eq("org_id", ctx.org_id)\
          .eq("project_id", project_id).eq("stage_id", body.stage_id).limit(1).execute().data
    if not doc:
        draft = DraftReq(stage_id=body.stage_id, area=body.area, title=body.title or "Stage Sign-Off",
                         summary=body.message or "Please review and acknowledge completion of this stage.",
                         bullets=[], acceptance="I acknowledge and approve the above.", footer="Signed electronically via TEAIM")
        from ..routers.signoff_docs_gen import generate_from_prompt
        _ = generate_from_prompt(draft, project_id, ctx)
        doc = sbs.table("signoff_docs").select("id,status").eq("org_id", ctx.org_id)\
              .eq("project_id", project_id).eq("stage_id", body.stage_id).limit(1).execute().data
        if not doc: raise HTTPException(500, "Failed to create sign-off draft")
    doc_id = doc[0]["id"]

    # 2) CC presets (leads & PMs)
    cc_list = set([e.strip() for e in (body.cc or []) if e.strip()])
    try:
        mem = sb.table("project_members").select("user_id,role")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id).execute().data or []
        prof = sb.table("users_profile").select("user_id,email").execute().data or []
        email_map = {p["user_id"]: p.get("email") for p in prof if p.get("user_id")}
        if body.cc_all_leads:
            for m in mem:
                if (m.get("role") or "").lower()=="lead":
                    em = email_map.get(m["user_id"])
                    if em: cc_list.add(em)
        if body.cc_all_pms:
            for m in mem:
                if (m.get("role") or "").lower()=="pm":
                    em = email_map.get(m["user_id"])
                    if em: cc_list.add(em)
    except Exception:
        pass

    # 3) Send token emails via existing request_sign endpoint (guards + audit there)
    from ..routers.signoff_docs import request_sign as _req
    sent = []
    for email in body.emails:
        _ = _req(type("B", (), {"doc_id": doc_id, "email_to": email, "expires_hours": body.expires_hours})(), project_id, ctx)
        sent.append(email)

    # 4) Optional FYI to CC (no tokens)
    if cc_list:
        try:
            from ..email.util import mailgun_send_html, send_guard
            ok, _ = send_guard(sb, ctx.org_id, project_id, "signoff_cc", ",".join(sorted(cc_list)))
            if ok:
                base = os.getenv("APP_BASE_URL","").rstrip("/")
                link = f"{base}/projects/{project_id}/signoff/docs"
                mailgun_send_html(list(cc_list), f"[FYI] Sign-off requested: {body.title}",
                                  f"<p>A sign-off was requested for <b>{body.title}</b>.</p><p><a href='{link}'>View in TEAIM</a></p>")
        except Exception:
            pass

    # 5) Audit
    try:
        sbs.table("audit_events").insert({
            "org_id": ctx.org_id, "project_id": project_id, "actor_id": ctx.user_id,
            "kind": "stage.request_signoff",
            "details": {"stage_id": body.stage_id, "emails": body.emails, "cc": sorted(list(cc_list)), "title": body.title}
        }).execute()
    except Exception:
        pass

    return {"ok": True, "sent": sent, "cc": sorted(list(cc_list))}


(If you want to append message to the actual token email body later, we can patch signoff_docs.request_sign to include a note; for now the message is included when creating a draft and in the FYI email if CC list exists.)

1B) Frontend — modal v3.3 (remember last recipients/presets per stage)

client/src/components/SignoffRequestModal.tsx (replace your existing v3)

import { useEffect, useMemo, useRef, useState } from "react";
import { getJSON } from "@/lib/authFetch";

const DEFAULT_AREAS = ["HCM","Payroll","Financials","Time","Integrations","Security","Reporting","Cutover"];

export default function SignoffRequestModal({
  projectId, stageId, stageTitle, stageArea, onClose
}:{
  projectId: string; stageId: string; stageTitle?: string; stageArea?: string; onClose: ()=>void
}){
  const [members,setMembers]=useState<{user_id:string;email:string;role?:string;can_sign_all?:boolean;sign_areas?:string[]}[]>([]);
  const [signers,setSigners]=useState<typeof members>([]);
  const [q,setQ]=useState("");
  const [area,setArea]=useState(stageArea||"");
  const [picked,setPicked]=useState<string[]>([]);
  const [cc,setCc]=useState<string>("");
  const [ccAllLeads,setCcAllLeads]=useState(false);
  const [ccAllPMs,setCcAllPMs]=useState(false);
  const [msg,setMsg]=useState<string>("");
  const [busy,setBusy]=useState(false);
  const inputRef = useRef<HTMLInputElement|null>(null);

  const storeKey = `kap.stageReq.${projectId}.${stageId}`; // remember last

  useEffect(()=>{ inputRef.current?.focus(); },[]);

  useEffect(()=>{ (async()=>{
    try{
      const m = await getJSON(`/api/members/all?project_id=${projectId}`); setMembers(m.items||[]);
      const d = await getJSON(`/api/members/signers?project_id=${projectId}${stageArea?`&area=${encodeURIComponent(stageArea)}`:""}`); setSigners(d.items||[]);
    }catch{ setMembers([]); setSigners([]); }
    try{
      const saved = JSON.parse(localStorage.getItem(storeKey) || "{}");
      if (saved.emails) setPicked(saved.emails);
      if (saved.cc) setCc(saved.cc);
      if (saved.area) setArea(saved.area);
      if (saved.message) setMsg(saved.message);
      if (saved.ccAllLeads) setCcAllLeads(true);
      if (saved.ccAllPMs) setCcAllPMs(true);
    }catch{}
  })(); },[projectId, stageArea, storeKey]);

  const hits = useMemo(()=>{
    const pool = members.map(m=>{
      const s = signers.find(x=>x.user_id===m.user_id);
      const allowed = s?.allowed || m.can_sign_all || (area && (m.sign_areas||[]).includes(area));
      return {...m, allowed};
    });
    const qq = q.toLowerCase();
    return pool.filter(p=>{
      const matchQ = !qq || (p.email||"").toLowerCase().includes(qq) || (p.role||"").toLowerCase().includes(qq);
      const matchArea = !area || p.can_sign_all || (p.sign_areas||[]).includes(area);
      return matchQ && matchArea;
    }).sort((a,b)=> (a.allowed===b.allowed) ? ((a.role||"").localeCompare(b.role||"")) : (a.allowed? -1 : 1));
  },[members, signers, q, area]);

  function toggle(email:string){
    setPicked(p => p.includes(email) ? p.filter(x=>x!==email) : [...p, email]);
  }

  function applyPreset(which:"leads"|"pms"){
    const wanted = which==="leads" ? ["lead"] : ["pm"];
    const emails = hits.filter(h=> wanted.includes((h.role||"").toLowerCase()) ).map(h=>h.email);
    setPicked(prev => Array.from(new Set([ ...prev, ...emails ])));
    which==="leads"? setCcAllLeads(true) : setCcAllPMs(true);
  }

  async function send(){
    if (!picked.length) return alert("Pick at least one recipient");
    const ccList = cc.split(",").map(x=>x.trim()).filter(Boolean);
    setBusy(true);
    try{
      await fetch(`/api/stages/request_signoff_batch?project_id=${projectId}`, {
        method:"POST", credentials:"include", headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ stage_id: stageId, emails: picked, cc: ccList, cc_all_leads: ccAllLeads, cc_all_pms: ccAllPMs, title: stageTitle, area, message: msg })
      });
      localStorage.setItem(storeKey, JSON.stringify({ emails:picked, cc, area, message:msg, ccAllLeads, ccAllPMs }));
      onClose(); alert(`Request sent to ${picked.length} recipient(s)`);
    }catch(e:any){ alert(String(e?.message||e)); setBusy(false); }
  }

  return (
    <div className="fixed inset-0 bg-black/40 z-[200]" onClick={onClose}>
      <div className="mx-auto mt-[8vh] w-[720px] max-w-[96%] bg-white dark:bg-neutral-900 rounded shadow-xl border"
           onClick={e=>e.stopPropagation()}>
        <div className="p-3 border-b">
          <div className="text-sm font-medium">Request Sign-Off</div>
          <div className="text-xs text-muted-foreground">{stageTitle}{stageArea?` • ${stageArea}`:""}</div>
        </div>
        <div className="p-3 space-y-2">
          <div className="flex items-center gap-2">
            <input ref={inputRef} className="border rounded p-2 w-full text-sm"
                   placeholder="Search recipients (email or role)…" value={q} onChange={e=>setQ(e.target.value)} />
            <div className="flex items-center gap-2">
              {DEFAULT_AREAS.map(a=>(
                <button key={a} className={`brand-btn text-[11px] ${area===a?'pulse-once':''}`} onClick={()=>setArea(a)}>{a}</button>
              ))}
              <button className="brand-btn text-[11px]" onClick={()=>setArea("")}>All</button>
            </div>
          </div>

          <div className="flex items-center gap-2 text-xs">
            <button className="brand-btn text-xs" onClick={()=>applyPreset("leads")}>+ Leads</button>
            <button className="brand-btn text-xs" onClick={()=>applyPreset("pms")}>+ PMs</button>
          </div>

          <div className="max-h-[36vh] overflow-auto border rounded">
            {hits.map(h=>(
              <label key={h.email} className="flex items-center gap-2 px-2 py-1 hover:bg-black/5 dark:hover:bg-white/5">
                <input type="checkbox" checked={picked.includes(h.email)} onChange={()=>toggle(h.email)} />
                <span className="text-sm">{h.email}</span>
                <span className="text-[11px] text-muted-foreground ml-auto">
                  {h.role || ""} {h.can_sign_all ? "• signer(all)" : h.sign_areas?.length ? `• signer(${h.sign_areas.join(",")})`:""}
                </span>
                {!h.allowed && area && <span className="text-[11px] text-red-500 ml-1">(area mismatch)</span>}
              </label>
            ))}
            {!hits.length && <div className="p-2 text-xs text-muted-foreground">No matches</div>}
          </div>

          <div className="grid md:grid-cols-2 gap-2">
            <input className="border rounded p-2 text-sm" placeholder="CC (comma-separated)" value={cc} onChange={e=>setCc(e.target.value)} />
            <div className="flex items-center gap-2 text-xs">
              <label className="flex items-center gap-1"><input type="checkbox" checked={ccAllLeads} onChange={e=>setCcAllLeads(e.target.checked)}/> CC all leads</label>
              <label className="flex items-center gap-1"><input type="checkbox" checked={ccAllPMs} onChange={e=>setCcAllPMs(e.target.checked)}/> CC all PMs</label>
            </div>
          </div>
          <textarea className="border rounded p-2 w-full text-sm" rows={3}
                    placeholder="Optional message…" value={msg} onChange={e=>setMsg(e.target.value)} />
        </div>
        <div className="p-3 border-t flex justify-end gap-2">
          <button className="brand-btn text-xs" onClick={onClose}>Cancel</button>
          <button className="brand-btn text-xs swoosh" onClick={send} disabled={busy || picked.length===0}>
            {busy?"Sending…":`Send (${picked.length})`}
          </button>
        </div>
      </div>
    </div>
  );
}

2) Stages Editor — combined undo & toast

(You already added keyboard date logic in v2.12; add the transaction stack & “Revert last” button.)

client/src/pages/Stages.tsx (augment prior code)

const [txStack,setTxStack] = useState<Record<string,{start_date?:string;end_date?:string}[]>>({});

function pushTx(id:string, prev:{start_date?:string; end_date?:string}){
  setTxStack(s => ({...s, [id]: [...(s[id]||[]), prev]}));
}
function popTx(id:string){
  const arr = txStack[id]||[]; if (!arr.length) return null;
  const prev = arr[arr.length-1];
  setTxStack(s => ({...s, [id]: arr.slice(0, -1)}));
  return prev;
}

async function revertLast(id:string){
  const prev = popTx(id); if (!prev) return;
  await saveField(id, prev);
  toast({ title:"Reverted", description:"Stage dates restored" });
}

// In start_date/end_date change handlers, call pushTx(id,{start_date:s.start_date,end_date:s.end_date}) BEFORE applying the first change in the transaction.


Add button per row:

<div className="flex items-center justify-end gap-2">
  <button className="brand-btn text-xs" onClick={()=>revertLast(s.id)} disabled={!(txStack[s.id]||[]).length}>Revert last</button>
</div>

3) Digests → open filter panels + scroll to row

(You added anchor scroll already. Add openFilters & tab logic.)

client/src/pages/ActionsList.tsx

const params = new URLSearchParams((loc.hash || "").replace(/^#/, ""));
const openFilters = params.get("openFilters")==="1";
const anchorId = params.get("id") || (loc.hash.startsWith("#id=") ? loc.hash.slice(4) : "");
useEffect(()=>{
  if (openFilters) setFiltersOpen(true);
  if (anchorId){
    const el = document.querySelector(`[data-action-id="${anchorId}"]`) as HTMLElement|null;
    if (el){ el.scrollIntoView({behavior:"smooth",block:"center"}); el.classList.add("pulse-once"); setTimeout(()=>el.classList.remove("pulse-once"), 1500); }
  }
},[loc.key]);


client/src/pages/AdminAuditTimeline.tsx

const params = new URLSearchParams((loc.hash || "").replace(/^#/, ""));
const openFilters = params.get("openFilters")==="1";
const tab = params.get("tab"); // "risks" | "decisions" | ...
const anchorId = params.get("id") || (loc.hash.startsWith("#id=") ? loc.hash.slice(4) : "");
useEffect(()=>{
  if (openFilters) setFiltersOpen(true);
  if (tab) setActiveTab(tab as any);
  if (anchorId){
    const el = document.querySelector(`[data-audit-id="${anchorId}"]`) as HTMLElement|null;
    if (el){ el.scrollIntoView({behavior:"smooth",block:"center"}); el.classList.add("pulse-once"); setTimeout(()=>el.classList.remove("pulse-once"), 1500); }
  }
},[loc.key]);


Now generate digest links like:

/projects/:pid/actions/list#openFilters=1&id=<actionId>
/projects/:pid/admin/audit-timeline#openFilters=1&tab=risks&id=<riskId>

4) Wellness Admin — trend line + moving average + CSV of top responders
4A) Backend (responders trend & CSV)

server/routers/wellness_responders_trend.py (new)

from fastapi import APIRouter, Depends, Query
from datetime import datetime, timedelta, timezone
from ..tenant import TenantCtx
from ..guards import require_role
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/wellness", tags=["wellness"])

@router.get("/responders_trend")
def responders_trend(project_id: str = Query(...), days: int = 30,
                     ctx: TenantCtx = Depends(require_role({"owner","admin","pm"}))):
    sb = get_user_supabase(ctx)
    end = datetime.now(timezone.utc).date()
    days = 7 if days==7 else 30
    start = end - timedelta(days=days-1)
    try:
        rows = sb.table("team_wellness").select("user_id,created_at")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id)\
               .gte("created_at", start.isoformat()).execute().data or []
    except Exception:
        rows = []
    by = {}
    for r in rows:
        d = (r.get("created_at") or "")[:10]
        if not d: continue
        by[d] = by.get(d,0) + 1
    out=[]
    for i in range(days):
        day = (start + timedelta(days=i)).isoformat()
        out.append({"date": day, "count": by.get(day,0)})
    return {"items": out}


server/routers/wellness_top_export.py (new):

from fastapi import APIRouter, Depends, Query
from fastapi.responses import StreamingResponse
import io, csv
from datetime import datetime, timedelta, timezone
from ..tenant import TenantCtx
from ..guards import require_role
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/wellness", tags=["wellness"])

@router.get("/top_responders.csv")
def top_export(project_id: str = Query(...), days: int = 30,
               ctx: TenantCtx = Depends(require_role({"owner","admin","pm"}))):
    sb = get_user_supabase(ctx)
    days = 7 if days==7 else 30
    end = datetime.now(timezone.utc).date()
    start = end - timedelta(days=days-1)
    prev_start = start - timedelta(days=days)
    prev_end = start - timedelta(days=1)

    try:
        rows = sb.table("team_wellness").select("user_id,created_at")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id)\
               .gte("created_at", start.isoformat()).execute().data or []
        prev_rows = sb.table("team_wellness").select("user_id,created_at")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id)\
               .gte("created_at", prev_start.isoformat()).lte("created_at", prev_end.isoformat()).execute().data or []
    except Exception:
        rows=[]; prev_rows=[]

    cur = {}; prev={}
    for r in rows: cur[r["user_id"]] = cur.get(r["user_id"],0) + 1
    for r in prev_rows: prev[r["user_id"]] = prev.get(r["user_id"],0) + 1
    items = []
    for u,c in cur.items():
        items.append({"user_id":u, "checkins":c, "delta": c - prev.get(u,0)})

    s = io.StringIO(); w = csv.writer(s); w.writerow(["user_id","checkins","delta"])
    for r in sorted(items, key=lambda x:(-x["checkins"], -x["delta"])): w.writerow([r["user_id"], r["checkins"], r["delta"]])
    s.seek(0)
    return StreamingResponse(iter([s.read()]), media_type="text/csv",
      headers={"Content-Disposition": 'attachment; filename="top_responders.csv"'})


Mount in server/main.py:

from .routers import wellness_responders_trend, wellness_top_export
app.include_router(wellness_responders_trend.router)
app.include_router(wellness_top_export.router)

4B) Frontend — trend line with moving average

client/src/components/AdminWellnessTrend.tsx (replace)

import { useEffect, useState } from "react";
import { getJSON } from "@/lib/authFetch";
import { useParams } from "react-router-dom";

export default function AdminWellnessTrend({ days }:{ days:7|30 }){
  const { projectId } = useParams();
  const [data,setData]=useState<{date:string;count:number}[]>([]);
  useEffect(()=>{ (async()=>{
    try{ const d = await getJSON(`/api/wellness/responders_trend?project_id=${projectId}&days=${days}`); setData(d.items||[]); }
    catch{ setData([]); }
  })(); },[projectId, days]);

  const max = Math.max(1, ...data.map(d=>d.count));
  const toPts = (arr:number[]) => arr.map((v,i)=> `${(i/(arr.length-1))*100},${100 - (v/max)*100}`).join(" ");
  const series = data.map(d=>d.count);
  // 3-point moving average
  const ma = series.map((v,i,a)=> Math.round(((a[i-1]??v)+(v)+(a[i+1]??v))/3));

  return (
    <div className="brand-card p-3">
      <div className="text-sm font-medium mb-1">Responders Trend (last {days}d)</div>
      <svg viewBox="0 0 100 100" className="w-full h-[120px]">
        <polyline fill="none" stroke="var(--brand-accent)" strokeWidth="1.5" points={toPts(series)} />
        <polyline fill="none" stroke="#19d492" strokeWidth="1" points={toPts(ma)} />
      </svg>
      <div className="text-xs text-muted-foreground mt-1">Aqua = daily; Green = 3-pt MA</div>
    </div>
  );
}


And on your Admin page, add an Export Top Responders button where you show the responders:

<button className="brand-btn text-xs" onClick={()=> downloadGET(`/api/wellness/top_responders.csv?project_id=${projectId}&days=${range}`, "top_responders.csv")}>
  Export Top Responders
</button>

5) 60-second validation

Request Sign-Off v3.3 — search members, area chips, CC all Leads/PMs, remembers last recipients

Stages — “Revert last” restores previous start/end; duration preserved forward/backward with keyboard

Digests — links open filter panels and scroll to row on landing pages

Wellness — trend line with MA, Top Responders CSV, per-user sparkline + date range modal