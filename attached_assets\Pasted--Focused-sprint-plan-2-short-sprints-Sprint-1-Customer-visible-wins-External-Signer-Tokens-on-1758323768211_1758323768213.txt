✅ Focused sprint plan (2 short sprints)
Sprint 1 — Customer-visible wins

External Signer Tokens (one-click email approval without login)

Weekly Digest (actions/risks/decisions + overdue sign-offs, with quiet hours & caps)

Timeline UI (phases → bars from timeline memories)

Acceptance:

Customer receives sign-off email, approves via token page, stage → signed_off, audit entries written.

Manual “Send Digest Now” works; scheduled job skips during quiet hours and respects daily cap.

Timeline page renders phases from /mem/timeline.

Sprint 2 — Ops polish

Audit Viewer (filter by actor/kind/date)

Meeting Summaries CSV export

(Scaffold) Quiet hours/send caps stored in DB and enforced by mailer

Acceptance:

Admin can filter audit events and export rows.

Meeting Summaries page downloads a CSV that matches the table.

During quiet hours or after cap hit, emails are queued or skipped with log entries.

🗃️ Supabase SQL (run in SQL editor)
-- 1) External signer tokens (single-use)
create table if not exists public.signoff_tokens (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null,
  project_id uuid not null,
  stage_id uuid not null,
  email text not null,
  token text not null unique,          -- 40–64 random chars
  expires_at timestamptz not null,
  used_at timestamptz,
  created_at timestamptz not null default now()
);

-- RLS: members can see their project’s tokens (for audit); inserts via server.
alter table public.signoff_tokens enable row level security;
create policy "signoff_tokens_read_members" on public.signoff_tokens
  for select using (org_id = public.current_org() and public.is_member(org_id, project_id));

-- 2) Comms settings + send log (quiet hours & caps)
create table if not exists public.org_comms_settings (
  org_id uuid primary key,
  tz text not null default 'America/Los_Angeles',
  quiet_start time with time zone default '21:00',
  quiet_end   time with time zone default '07:00',
  daily_send_cap int not null default 200
);

create table if not exists public.comms_send_log (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null,
  project_id uuid,
  kind text not null,          -- 'digest' | 'signoff' | 'onboarding' | ...
  to_email text not null,
  created_at timestamptz not null default now()
);

alter table public.org_comms_settings enable row level security;
alter table public.comms_send_log enable row level security;
create policy "comms_read_members" on public.comms_send_log for select
  using (org_id = public.current_org());
create policy "comms_settings_read_members" on public.org_comms_settings for select
  using (org_id = public.current_org());

-- 3) PostgREST refresh
select pg_notify('pgrst','reload schema');

🐍 FastAPI — paste-ready routers & helpers
A) Mail helper w/ quiet hours & daily cap

server/app/email/util.py

import os, requests, datetime as dt
from zoneinfo import ZoneInfo

MG_DOMAIN = os.getenv("MAILGUN_DOMAIN")
MG_KEY = os.getenv("MAILGUN_API_KEY")

def in_quiet_hours(tz_name: str, quiet_start: str, quiet_end: str, now_utc: dt.datetime | None = None) -> bool:
    now_utc = now_utc or dt.datetime.now(dt.timezone.utc)
    tz = ZoneInfo(tz_name)
    local = now_utc.astimezone(tz)
    qs = dt.time.fromisoformat(quiet_start)
    qe = dt.time.fromisoformat(quiet_end)
    # window can wrap midnight
    if qs <= qe:
        return qs <= local.timetz() <= qe
    return local.timetz() >= qs or local.timetz() <= qe

def send_guard(sb, org_id: str, project_id: str | None, kind: str, to_email: str) -> tuple[bool,str]:
    # get settings or defaults
    s = sb.table("org_comms_settings").select("tz,quiet_start,quiet_end,daily_send_cap")\
        .eq("org_id", org_id).single().execute()
    if s.data:
        tz, qs, qe, cap = s.data["tz"], s.data["quiet_start"], s.data["quiet_end"], s.data["daily_send_cap"]
    else:
        tz, qs, qe, cap = "America/Los_Angeles","21:00:00+00:00","07:00:00+00:00",200
    if in_quiet_hours(tz, qs, qe):
        return False, f"Quiet hours active ({qs}-{qe} {tz})"
    # count today sends
    today_utc = dt.datetime.now(dt.timezone.utc).date()
    start = dt.datetime.combine(today_utc, dt.time(0,0), tzinfo=dt.timezone.utc)
    end   = dt.datetime.combine(today_utc, dt.time(23,59,59), tzinfo=dt.timezone.utc)
    cnt = sb.table("comms_send_log").select("id", count="exact")\
        .eq("org_id", org_id).gte("created_at", start.isoformat()).lte("created_at", end.isoformat()).execute()
    if (cnt.count or 0) >= cap:
        return False, f"Daily send cap {cap} reached"
    return True, ""

def log_send(sb, org_id: str, project_id: str | None, kind: str, to_email: str):
    sb.table("comms_send_log").insert({
        "org_id": org_id, "project_id": project_id, "kind": kind, "to_email": to_email
    }).execute()

def mailgun_send_html(to_email: str, subject: str, html: str):
    if not (MG_DOMAIN and MG_KEY): return None
    return requests.post(
        f"https://api.mailgun.net/v3/{MG_DOMAIN}/messages",
        auth=("api", MG_KEY),
        data={"from": f"TEAIM <no-reply@{MG_DOMAIN}>", "to": [to_email], "subject": subject, "html": html},
        timeout=20
    )

B) External Signer Tokens

server/app/routers/signoff_external.py

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel
from datetime import datetime, timedelta, timezone
import os, secrets, json

from ..tenant import TenantCtx
from ..guards import require_role, member_ctx, require_signer_or_admin
from ..deps import get_user_supabase, get_service_supabase
from ..email.util import mailgun_send_html, send_guard, log_send

router = APIRouter(prefix="/api/signoff", tags=["signoff"])
PM_PLUS = require_role({"owner","admin","pm","lead"})

class RequestExternalBody(BaseModel):
    stage_id: str
    email_to: str
    message: str | None = None
    expires_hours: int = 72

@router.post("/request-external")
def request_external(body: RequestExternalBody, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb_user = get_user_supabase(ctx)
    # ensure stage belongs to project/org
    st = sb_user.table("project_stages").select("id,title").eq("id", body.stage_id)\
         .eq("project_id", project_id).eq("org_id", ctx.org_id).single().execute().data
    if not st: raise HTTPException(404, "Stage not found")

    # create token (service role to bypass RLS for later token validation)
    sb = get_service_supabase()
    token = secrets.token_urlsafe(40)
    sb.table("signoff_tokens").insert({
        "org_id": ctx.org_id, "project_id": project_id, "stage_id": body.stage_id,
        "email": body.email_to, "token": token,
        "expires_at": (datetime.now(timezone.utc) + timedelta(hours=body.expires_hours)).isoformat()
    }).execute()

    app_url = os.getenv("APP_BASE_URL", "")
    link = f"{app_url}/signoff/{token}"
    html = f"""
      <p>You have a stage awaiting approval: <b>{st['title']}</b></p>
      <p><a href="{link}">Review & Approve/Reject</a> (expires in {body.expires_hours} hours)</p>
      <p>{body.message or ''}</p>
      <p>— TEAIM</p>
    """

    ok, reason = send_guard(sb_user, ctx.org_id, project_id, "signoff", body.email_to)
    if not ok:
        # still save token; caller can resend later
        return {"ok": False, "reason": reason, "token_link": link}

    mailgun_send_html(body.email_to, "TEAIM: Stage sign-off requested", html)
    log_send(sb_user, ctx.org_id, project_id, "signoff", body.email_to)
    return {"ok": True, "token_link": link}

# Public token flow (no auth): validate + decide
class TokenDecisionBody(BaseModel):
    decision: str   # approved | rejected
    notes: str | None = None

def _get_token_row(sb_service, token: str):
    row = sb_service.table("signoff_tokens").select("*").eq("token", token).single().execute().data
    if not row: raise HTTPException(404, "Invalid or expired token")
    if row["used_at"] is not None: raise HTTPException(400, "Token already used")
    if datetime.now(timezone.utc) > datetime.fromisoformat(row["expires_at"]):
        raise HTTPException(400, "Token expired")
    return row

@router.get("/token/validate")
def token_validate(token: str):
    sbs = get_service_supabase()
    row = _get_token_row(sbs, token)
    # minimal info to render page
    st = sbs.table("project_stages").select("title,status").eq("id", row["stage_id"]).single().execute().data
    return {"ok": True, "stage_title": st["title"], "status": st["status"], "email": row["email"]}

@router.post("/token/decision")
def token_decide(token: str, body: TokenDecisionBody):
    if body.decision not in ("approved","rejected"):
        raise HTTPException(400, "Invalid decision")
    sbs = get_service_supabase()
    row = _get_token_row(sbs, token)
    status = "signed_off" if body.decision == "approved" else "rejected"

    # update stage & audit (service role; scoped by ids already on row)
    sbs.table("project_stages").update({
        "status": status,
        "signoff_by": None,  # external signer not a user
        "signoff_date": datetime.now(timezone.utc).isoformat(),
        "signoff_decision": body.decision,
        "signoff_notes": (body.notes or f"External decision by {row['email']}")
    }).eq("id", row["stage_id"]).eq("org_id", row["org_id"]).eq("project_id", row["project_id"]).execute()

    sbs.table("audit_events").insert({
        "org_id": row["org_id"], "project_id": row["project_id"],
        "actor_id": None, "kind": f"stage.{body.decision}",
        "details": json.dumps({"stage_id": row["stage_id"], "email": row["email"], "via":"external_token"})
    }).execute()

    sbs.table("signoff_tokens").update({"used_at": datetime.now(timezone.utc).isoformat()})\
       .eq("id", row["id"]).execute()

    return {"ok": True, "status": status}


Mount it: app.include_router(signoff_external.router).

C) Weekly Digest (manual + scheduled)

server/app/routers/digest.py

from fastapi import APIRouter, Depends, HTTPException, Query
from datetime import datetime, timedelta, timezone
from ..tenant import TenantCtx
from ..guards import member_ctx, require_role
from ..deps import get_user_supabase
from ..email.util import mailgun_send_html, send_guard, log_send

router = APIRouter(prefix="/api/digest", tags=["digest"])
PM_PLUS = require_role({"owner","admin","pm","lead"})

def _window(days=7):
   end = datetime.now(timezone.utc)
   start = end - timedelta(days=days)
   return start, end

def _digest_html(project_code: str, counts: dict, overdue: list[dict]) -> str:
   li = "".join([f"<li>{o['title']} (requested {o['requested_at']})</li>" for o in overdue])
   return f"""
     <h3>Weekly Digest — {project_code}</h3>
     <p>New/Updated (last 7 days):</p>
     <ul>
       <li>Actions: {counts.get('actions',0)}</li>
       <li>Risks: {counts.get('risks',0)}</li>
       <li>Decisions: {counts.get('decisions',0)}</li>
     </ul>
     <p>Overdue Sign-Offs:</p>
     <ul>{li or '<li>None</li>'}</ul>
   """

@router.post("/send-weekly")
def send_weekly(project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    start, end = _window(7)

    # counts by table (adjust names if they differ)
    def count(table): 
        r = sb.table(table).select("id", count="exact").eq("org_id", ctx.org_id)\
            .eq("project_id", project_id).gte("updated_at", start.isoformat()).lte("updated_at", end.isoformat()).execute()
        return r.count or 0

    counts = {
        "actions": count("actions"),
        "risks": count("risks"),
        "decisions": count("decisions"),
    }

    overdue = sb.table("project_stages").select("title,requested_at")\
        .eq("org_id", ctx.org_id).eq("project_id", project_id).eq("status","in_review").execute().data

    proj = sb.table("projects").select("code").eq("id", project_id).single().execute().data
    html = _digest_html(proj["code"], counts, overdue)

    # naive recipient list: all members (you can refine by subscriptions matrix)
    members = sb.table("project_members").select("user_id").eq("project_id", project_id).execute().data
    # look up emails from your users table or contacts; for demo, send to admin only if you store emails elsewhere
    # Replace the next line with your real recipient query.
    recipients = [os.getenv("DIGEST_TEST_EMAIL")] if os.getenv("DIGEST_TEST_EMAIL") else []

    sent = []
    for email in recipients:
        ok, reason = send_guard(sb, ctx.org_id, project_id, "digest", email)
        if not ok: continue
        mailgun_send_html(email, f"Weekly Digest — {proj['code']}", html)
        log_send(sb, ctx.org_id, project_id, "digest", email)
        sent.append(email)

    return {"ok": True, "sent": sent, "counts": counts, "overdue": overdue}


Mount it: app.include_router(digest.router)
(If you want a real schedule, add a tiny scheduler to call this Fridays 09:00 org-local; I can wire that next.)

D) Meetings → CSV export

server/app/routers/meetings_export.py

from fastapi import APIRouter, Depends, Query
from fastapi.responses import StreamingResponse
import io, csv
from ..tenant import TenantCtx
from ..guards import member_ctx
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/meetings", tags=["meetings"])

@router.get("/export.csv")
def export_csv(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    # adjust select to your meetings view/source
    rows = sb.table("meetings").select("id,artifact_id,title,summary,actions_count,risks_count,decisions_count,created_at")\
           .eq("org_id", ctx.org_id).eq("project_id", project_id).order("created_at", desc=False).execute().data
    buf = io.StringIO()
    w = csv.writer(buf)
    w.writerow(["id","artifact_id","title","summary","actions","risks","decisions","created_at"])
    for r in rows:
        w.writerow([r["id"], r["artifact_id"], r.get("title",""), (r.get("summary") or "").replace("\n"," "), r["actions_count"], r["risks_count"], r["decisions_count"], r["created_at"]])
    buf.seek(0)
    return StreamingResponse(iter([buf.read()]), media_type="text/csv",
                             headers={"Content-Disposition":"attachment; filename=meeting_summaries.csv"})


Mount it: app.include_router(meetings_export.router).

E) Audit Viewer API

server/app/routers/audit.py

from fastapi import APIRouter, Depends, Query
from ..tenant import TenantCtx
from ..guards import member_ctx
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/audit", tags=["audit"])

@router.get("/list")
def list_audit(project_id: str = Query(...), kind: str | None = None,
               actor_id: str | None = None, before: str | None = None, after: str | None = None,
               ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    q = sb.table("audit_events").select("created_at,kind,actor_id,details").eq("org_id", ctx.org_id).eq("project_id", project_id)
    if kind: q = q.eq("kind", kind)
    if actor_id: q = q.eq("actor_id", actor_id)
    if after: q = q.gte("created_at", after)
    if before: q = q.lte("created_at", before)
    out = q.order("created_at", desc=True).limit(500).execute().data
    return {"events": out}


Mount it: app.include_router(audit.router).

🖥️ Frontend — minimal UIs
1) Public external sign-off page

client/src/pages/ExternalSignoff.tsx

import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";

export default function ExternalSignoff() {
  const { token } = useParams();
  const [stage, setStage] = useState<{title:string,status:string,email:string}|null>(null);
  const [notes,setNotes] = useState("");
  const [status,setStatus] = useState<string>("");

  useEffect(() => {
    (async () => {
      const r = await fetch(`/api/signoff/token/validate?token=${encodeURIComponent(token!)}`);
      if (r.ok) setStage(await r.json().then(d=>({title:d.stage_title,status:d.status,email:d.email})));
      else setStatus(await r.text());
    })();
  }, [token]);

  async function decide(decision:"approved"|"rejected") {
    const r = await fetch(`/api/signoff/token/decision?token=${encodeURIComponent(token!)}`, {
      method:"POST", headers:{"Content-Type":"application/json"},
      body: JSON.stringify({ decision, notes })
    });
    setStatus(r.ok ? `Success: ${decision}` : await r.text());
  }

  if (!stage) return <div className="p-8">{status || "Loading..."}</div>;
  return (
    <div className="max-w-xl mx-auto p-8 space-y-4">
      <h1 className="text-2xl font-semibold">Stage Sign-Off</h1>
      <div className="p-4 border rounded">
        <div className="font-medium">Stage: {stage.title}</div>
        <div className="text-sm text-muted-foreground">Status: {stage.status}</div>
        <div className="text-sm">For: {stage.email}</div>
      </div>
      <textarea className="w-full border rounded p-2" placeholder="Notes (optional)" value={notes} onChange={e=>setNotes(e.target.value)} />
      <div className="flex gap-2">
        <button className="px-3 py-2 rounded bg-black text-white" onClick={()=>decide("approved")}>Approve</button>
        <button className="px-3 py-2 rounded bg-red-600 text-white" onClick={()=>decide("rejected")}>Reject</button>
      </div>
      {status && <div className="text-sm">{status}</div>}
    </div>
  );
}


Route (public):

{ path: "/signoff/:token", element: <ExternalSignoff/> }

2) Timeline UI (bars)

client/src/components/TimelineGantt.tsx

import { useEffect, useState } from "react";

type Phase = { label:string; start:string; end:string };

export function TimelineGantt({ projectId }: { projectId: string }) {
  const [phases,setPhases] = useState<Phase[]>([]);
  useEffect(()=>{ (async ()=>{
    const r = await fetch(`/api/mem/timeline?project_id=${projectId}`);
    if (r.ok) {
      const data = await r.json();
      // expect entries with {label, start_date, end_date}
      setPhases((data.items||[]).map((x:any)=>({label:x.label, start:x.start_date, end:x.end_date})));
    }
  })(); },[projectId]);

  if (!phases.length) return <div className="text-sm text-muted-foreground">No phases yet.</div>;

  const min = Math.min(...phases.map(p=>new Date(p.start).getTime()));
  const max = Math.max(...phases.map(p=>new Date(p.end).getTime()));
  const span = Math.max(1, max - min);

  return (
    <div className="space-y-2">
      {phases.map(p=>{
        const s = (new Date(p.start).getTime()-min)/span*100;
        const e = (new Date(p.end).getTime()-min)/span*100;
        const w = Math.max(2, e - s);
        return (
          <div key={p.label}>
            <div className="text-xs mb-1">{p.label} <span className="text-muted-foreground">({p.start} → {p.end})</span></div>
            <div className="h-3 bg-gray-200 rounded relative">
              <div className="h-3 rounded absolute" style={{left:`${s}%`, width:`${w}%`}} />
            </div>
          </div>
        );
      })}
    </div>
  );
}


Page & route:

// client/src/pages/Timeline.tsx
import { useParams } from "react-router-dom";
import { TimelineGantt } from "@/components/TimelineGantt";
export default function TimelinePage(){
  const { projectId } = useParams();
  return <div className="p-6"><h1 className="text-xl font-semibold mb-4">Timeline</h1><TimelineGantt projectId={projectId!}/></div>;
}
// route
{ path: "/projects/:projectId/timeline", element: <TimelinePage/> }

3) Audit Viewer (quick filter UI)

client/src/pages/AuditViewer.tsx

import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";

type Event = { created_at:string; kind:string; actor_id:string|null; details:any };

export default function AuditViewer(){
  const { projectId } = useParams();
  const [items,setItems] = useState<Event[]>([]);
  const [kind,setKind] = useState(""); const [actor,setActor]=useState("");

  async function load(){
    const qs = new URLSearchParams({ project_id: projectId!, ...(kind?{kind}:{}) , ...(actor?{actor_id:actor}:{}) }).toString();
    const r = await fetch(`/api/audit/list?${qs}`); if (r.ok) setItems((await r.json()).events);
  }
  useEffect(()=>{ load(); },[projectId]);

  return (
    <div className="p-6 space-y-3">
      <h1 className="text-xl font-semibold">Audit Viewer</h1>
      <div className="flex gap-2">
        <input className="border rounded p-2" placeholder="kind (e.g., stage.approved)" value={kind} onChange={e=>setKind(e.target.value)} />
        <input className="border rounded p-2" placeholder="actor_id" value={actor} onChange={e=>setActor(e.target.value)} />
        <button className="px-3 py-2 bg-black text-white rounded" onClick={load}>Filter</button>
      </div>
      <div className="border rounded">
        {items.map((e,i)=>(
          <div key={i} className="p-3 border-b last:border-0">
            <div className="text-sm">{e.created_at} — <b>{e.kind}</b> — {e.actor_id || 'external'}</div>
            <pre className="text-xs whitespace-pre-wrap">{JSON.stringify(e.details,null,2)}</pre>
          </div>
        ))}
      </div>
    </div>
  );
}
// route
{ path: "/projects/:projectId/admin/audit", element: <AuditViewer/> }

4) Meeting Summaries — CSV button (tiny patch)

Where you render Meeting Summaries list, add:

<a className="px-3 py-2 rounded border" href={`/api/meetings/export.csv?project_id=${projectId}`} target="_blank" rel="noreferrer">
  Export CSV
</a>

🔬 Test script (what to verify)

External Signer:

PM requests external; email link shows /signoff/<token>.

Approve on public page → Stage = signed_off and audit_events includes stage.approved via external_token.

Reuse token → error “already used”.

Digest:

Upload docs from our earlier “Phase B/C/D” set.

POST /api/digest/send-weekly?project_id=... returns counts + recipients.

If quiet hours or cap hit, response shows reason and no send.

Timeline:

Load /projects/:id/timeline and see bars for Discovery/Build/Test/Cutover.

Audit Viewer:

Filter by kind=stage.requested shows last request; by actor shows your user or external.

Meeting CSV:

Download CSV; row counts match the Meeting Summaries table.

Next quick hits (I can drop these next)

Scheduler to call /digest/send-weekly each Friday 09:00 org-local.

OCR pipeline (detect low-text PDFs → pytesseract if available; fallback to review queue).

Role Matrix legend block on Members page.

Tenant Leak Sentinel route + small UI badge.

Say the word and I’ll wire the scheduler + OCR next, or tune any of the above to your exact file paths.