Next Big Build v2.15.0 + v2.15.1 (double-sized, copy-paste ready)

What this adds now (you’ll feel it immediately):

Area Admins (per functional area) — assign customer/partner admins who can work that area

Change Requests (CRs) — intake form, list + Kanban (Intake → Triage → Planned → In-Progress → Testing → Deployed → Closed), assignees, priority, risk, SLA indicators, watchers, CSV export

Release Calendar (skeleton) — releases with date windows; attach CRs; export notes

Guards — area admins gain edit rights on their areas (dev-safe fallback)

Notifications — CR updates and SLA breaches notify watchers (uses your existing notifier)

v2.15.0 — Area Admins + Change Requests (Intake → Kanban)
1) Backend — Area Admins

server/routers/area_admins.py (new)

from fastapi import APIRouter, Depends, Query
from pydantic import BaseModel
from ..tenant import TenantCtx
from ..guards import member_ctx, require_role
from ..deps import get_user_supabase

router = APIRouter(prefix="/api/areas", tags=["areas"])

class AdminBody(BaseModel):
    area: str
    user_id: str  # or email

@router.get("/admins")
def list_admins(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    try:
        rows = sb.table("area_admins").select("area,user_id")\
               .eq("org_id", ctx.org_id).eq("project_id", project_id).limit(2000).execute().data or []
        return {"items": rows}
    except Exception:
        return {"items": []}

PM_PLUS = require_role({"owner","admin","pm"})

@router.post("/admins/add")
def add_admin(body: AdminBody, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    try:
        sb.table("area_admins").upsert({
            "org_id": ctx.org_id, "project_id": project_id,
            "area": body.area, "user_id": body.user_id
        }, on_conflict="org_id,project_id,area,user_id").execute()
        return {"ok": True}
    except Exception:
        return {"ok": False}

@router.post("/admins/remove")
def remove_admin(area: str = Query(...), user_id: str = Query(...),
                 project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    try:
        sb.table("area_admins").delete().eq("org_id", ctx.org_id).eq("project_id", project_id)\
          .eq("area", area).eq("user_id", user_id).execute()
        return {"ok": True}
    except Exception:
        return {"ok": False}


Mount in server/main.py:

from .routers import area_admins
app.include_router(area_admins.router)


Guard helper (dev-safe): allow area admins to write area-scoped entities.

server/guards.py (add)

async def require_area_admin(area: str, ctx: TenantCtx):
    # PM+/Owner always allowed
    if ctx.role in ("owner","admin","pm"): return True
    try:
        sb = get_user_supabase(ctx)
        r = sb.table("area_admins").select("user_id").eq("org_id", ctx.org_id)\
             .eq("project_id", ctx.project_id).eq("area", area).eq("user_id", ctx.user_id).limit(1).execute().data
        return bool(r)
    except Exception:
        return False  # fail-closed


Use this in area-scoped updates (e.g., actions update_small) to allow non-PM area admins.

2) Backend — Change Requests (CRs)

server/routers/changes.py (new)

from fastapi import APIRouter, Depends, Query
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime, timezone
from ..tenant import TenantCtx
from ..guards import member_ctx, require_role
from ..deps import get_user_supabase
import io, csv

router = APIRouter(prefix="/api/changes", tags=["changes"])

STATUSES = ["intake","triage","planned","in_progress","testing","deployed","closed"]

class CR(BaseModel):
    id: Optional[str] = None
    title: str
    area: Optional[str] = None
    description: Optional[str] = None
    priority: Optional[str] = "medium"   # low|medium|high|urgent
    risk: Optional[str] = "medium"       # low|medium|high
    status: Optional[str] = "intake"
    assignee: Optional[str] = None       # user_id/email
    due_date: Optional[str] = None       # ISO date
    watchers: Optional[List[str]] = []

@router.get("/list")
def list_changes(project_id: str = Query(...), area: str | None = None,
                 status: str | None = None, ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    try:
        q = sb.table("changes").select("*").eq("org_id", ctx.org_id).eq("project_id", project_id)
        if area: q = q.eq("area", area)
        if status: q = q.eq("status", status)
        rows = q.order("created_at", desc=True).limit(2000).execute().data or []
        return {"items": rows}
    except Exception:
        return {"items": []}

PM_PLUS = require_role({"owner","admin","pm"})

@router.post("/upsert")
def upsert_change(body: CR, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    try:
        data = body.model_dump()
        data.update({"org_id": ctx.org_id, "project_id": project_id})
        if body.id:
            sb.table("changes").update(data).eq("org_id", ctx.org_id).eq("project_id", project_id).eq("id", body.id).execute()
        else:
            sb.table("changes").insert(data).execute()
        return {"ok": True}
    except Exception:
        return {"ok": False}

@router.post("/transition")
def transition(id: str = Query(...), to: str = Query(...), project_id: str = Query(...),
               ctx: TenantCtx = Depends(PM_PLUS)):
    if to not in STATUSES: return {"ok": False, "error": "bad status"}
    sb = get_user_supabase(ctx)
    try:
        sb.table("changes").update({"status": to}).eq("org_id", ctx.org_id)\
          .eq("project_id", project_id).eq("id", id).execute()
        # notify watchers (best effort)
        try:
            ch = sb.table("changes").select("title,watchers").eq("org_id",ctx.org_id).eq("project_id",project_id).eq("id",id).single().execute().data or {}
            for w in (ch.get("watchers") or []):
                # rely on your notification system
                sb.table("notifications").insert({
                  "org_id": ctx.org_id, "project_id": project_id,
                  "to_user": w, "kind": "change_update",
                  "payload": {"id": id, "title": ch.get("title"), "status": to}
                }).execute()
        except Exception: ...
        return {"ok": True}
    except Exception:
        return {"ok": False}

@router.get("/export.csv")
def export_csv(project_id: str = Query(...), area: str | None = None, status: str | None = None,
               ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    try:
        q = sb.table("changes").select("*").eq("org_id", ctx.org_id).eq("project_id", project_id)
        if area: q = q.eq("area", area)
        if status: q = q.eq("status", status)
        rows = q.order("created_at", desc=True).limit(5000).execute().data or []
    except Exception:
        rows=[]
    cols = ["id","title","area","description","priority","risk","status","assignee","due_date","watchers"]
    s=io.StringIO(); w=csv.writer(s); w.writerow(cols)
    for r in rows: w.writerow([r.get(c) for c in cols])
    s.seek(0)
    from fastapi.responses import StreamingResponse
    return StreamingResponse(iter([s.read()]), media_type="text/csv",
      headers={"Content-Disposition": 'attachment; filename="changes.csv"'})


Mount in server/main.py:

from .routers import changes
app.include_router(changes.router)

3) Frontend — Changes Intake form + CR Kanban

A. Intake form — client/src/pages/ChangeIntake.tsx (new)

import { useState } from "react";
import { useParams } from "react-router-dom";
import { postJSON } from "@/lib/authFetch";
import PageHeading from "@/components/PageHeading";

export default function ChangeIntake(){
  const { projectId } = useParams();
  const [f,setF]=useState({ title:"", area:"", description:"", priority:"medium", risk:"medium", assignee:"", due_date:"" });
  async function submit(){
    if (!f.title.trim()) return alert("Title required");
    await postJSON(`/api/changes/upsert?project_id=${projectId}`, { ...f, status:"intake", watchers:[] });
    alert("Change submitted"); setF({ title:"", area:"", description:"", priority:"medium", risk:"medium", assignee:"", due_date:"" });
  }
  return (
    <div>
      <PageHeading title="Change Request — Intake" crumbs={[{label:"Execution"},{label:"Changes"}]} />
      <div className="brand-card p-3 grid md:grid-cols-2 gap-2">
        <input className="border rounded p-2" placeholder="Title" value={f.title} onChange={e=>setF({...f,title:e.target.value})}/>
        <input className="border rounded p-2" placeholder="Area (e.g., HCM)" value={f.area} onChange={e=>setF({...f,area:e.target.value})}/>
        <textarea className="border rounded p-2 md:col-span-2" rows={4} placeholder="Description" value={f.description} onChange={e=>setF({...f,description:e.target.value})}/>
        <select className="border rounded p-2" value={f.priority} onChange={e=>setF({...f,priority:e.target.value})}>
          {["low","medium","high","urgent"].map(x=><option key={x} value={x}>{x}</option>)}
        </select>
        <select className="border rounded p-2" value={f.risk} onChange={e=>setF({...f,risk:e.target.value})}>
          {["low","medium","high"].map(x=><option key={x} value={x}>{x}</option>)}
        </select>
        <input className="border rounded p-2" placeholder="Assignee (email)" value={f.assignee} onChange={e=>setF({...f,assignee:e.target.value})}/>
        <input type="date" className="border rounded p-2" value={f.due_date} onChange={e=>setF({...f,due_date:e.target.value})}/>
        <div className="md:col-span-2 flex justify-end"><button className="brand-btn text-xs swoosh" onClick={submit}>Submit</button></div>
      </div>
    </div>
  );
}


B. Kanban — client/src/pages/ChangeKanban.tsx (new)

import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import { getJSON, postJSON } from "@/lib/authFetch";
import PageHeading from "@/components/PageHeading";

const COLS = ["intake","triage","planned","in_progress","testing","deployed","closed"];

export default function ChangeKanban(){
  const { projectId } = useParams();
  const [items,setItems]=useState<any[]>([]);
  async function load(){ const d=await getJSON(`/api/changes/list?project_id=${projectId}`); setItems(d.items||[]); }
  useEffect(()=>{ load(); },[projectId]);

  async function move(id:string, to:string){ await postJSON(`/api/changes/transition?id=${id}&to=${to}&project_id=${projectId}`,{}); load(); }

  return (
    <div>
      <PageHeading title="Change Requests — Kanban" crumbs={[{label:"Execution"},{label:"Changes"}]}/>
      <div className="grid md:grid-cols-6 gap-3">
        {COLS.map(c=>(
          <div key={c} className="brand-card p-2 min-h-[240px]">
            <div className="text-xs font-medium mb-2 uppercase">{c.replace("_"," ")}</div>
            <div className="space-y-2">
              {items.filter(i=>(i.status||"intake")===c).map(i=>(
                <div key={i.id} className="border rounded p-2 text-xs bg-white/5">
                  <div className="font-medium">{i.title}</div>
                  <div className="text-muted-foreground">Area: {i.area||"—"} · P: {i.priority} · R: {i.risk}</div>
                  <div className="flex gap-1 mt-1 flex-wrap">
                    {COLS.filter(x=>x!==c).slice(0,3).map(x=><button key={x} className="brand-btn text-[11px]" onClick={()=>move(i.id,x)}>{x.replace("_"," ")}</button>)}
                  </div>
                </div>
              ))}
              {!items.some(i=>(i.status||"intake")===c) && <div className="text-xs text-muted-foreground">Empty</div>}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}


Routes in client/src/App.jsx:

import ChangeIntake from "@/pages/ChangeIntake";
import ChangeKanban from "@/pages/ChangeKanban";
// …
<Route path="/projects/:projectId/changes/intake" element={<ChangeIntake/>} />
<Route path="/projects/:projectId/changes/board" element={<ChangeKanban/>} />


Permissions thought: where updates touch an area, add an optional require_area_admin(area, ctx) gate if the user is not PM+/Admin (you can wrap the upsert_change or add a separate “update_small” for CRs with area admin allowance).

v2.15.1 — Release Calendar (skeleton) + Notes Export

Backend — server/routers/releases.py (new)

from fastapi import APIRouter, Depends, Query
from pydantic import BaseModel
from typing import Optional, List
from ..tenant import TenantCtx
from ..guards import require_role, member_ctx
from ..deps import get_user_supabase
import io, csv

router = APIRouter(prefix="/api/releases", tags=["releases"])
PM_PLUS = require_role({"owner","admin","pm"})

class Release(BaseModel):
    id: Optional[str] = None
    name: str
    window_start: Optional[str] = None
    window_end: Optional[str] = None
    notes: Optional[str] = None
    cr_ids: Optional[List[str]] = []

@router.get("/list")
def list_releases(project_id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    try:
        rows = sb.table("releases").select("*").eq("org_id", ctx.org_id).eq("project_id", project_id).order("window_start", desc=True).limit(500).execute().data or []
        return {"items": rows}
    except Exception:
        return {"items": []}

@router.post("/upsert")
def upsert_release(body: Release, project_id: str = Query(...), ctx: TenantCtx = Depends(PM_PLUS)):
    sb = get_user_supabase(ctx)
    try:
        data = body.model_dump(); data.update({"org_id": ctx.org_id, "project_id": project_id})
        sb.table("releases").upsert(data, on_conflict="org_id,project_id,id").execute()
        return {"ok": True}
    except Exception:
        return {"ok": False}

@router.get("/notes.csv")
def notes_csv(project_id: str = Query(...), id: str = Query(...), ctx: TenantCtx = Depends(member_ctx)):
    sb = get_user_supabase(ctx)
    try:
        r = sb.table("releases").select("name,cr_ids").eq("org_id",ctx.org_id).eq("project_id",project_id).eq("id",id).single().execute().data or {}
        crids = r.get("cr_ids") or []
        if not crids: raise Exception()
        cr = sb.table("changes").select("id,title,area,status").eq("org_id",ctx.org_id).eq("project_id",project_id).in_("id", crids).execute().data or []
    except Exception:
        cr=[]
    s=io.StringIO(); w=csv.writer(s); w.writerow(["id","title","area","status"])
    for c in cr: w.writerow([c.get("id"),c.get("title"),c.get("area"),c.get("status")])
    s.seek(0)
    from fastapi.responses import StreamingResponse
    return StreamingResponse(iter([s.read()]), media_type="text/csv",
      headers={"Content-Disposition": 'attachment; filename="release_notes.csv"'})


Mount in server/main.py:

from .routers import releases
app.include_router(releases.router)


Frontend — client/src/pages/Releases.tsx (new, minimal)

import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import { getJSON } from "@/lib/authFetch";
import { downloadGET } from "@/lib/download";
import PageHeading from "@/components/PageHeading";

export default function Releases(){
  const { projectId } = useParams();
  const [items,setItems]=useState<any[]>([]);
  useEffect(()=>{ (async()=>{ const d=await getJSON(`/api/releases/list?project_id=${projectId}`); setItems(d.items||[]); })(); },[projectId]);
  return (
    <div>
      <PageHeading title="Releases" crumbs={[{label:"Governance"},{label:"Releases"}]} />
      <div className="brand-card p-3">
        <div className="text-xs text-muted-foreground mb-2">Release Windows</div>
        <div className="overflow-auto">
          <table className="w-full text-sm">
            <thead><tr><th className="text-left p-1">Name</th><th className="text-left p-1">Window</th><th></th></tr></thead>
            <tbody>
              {(items||[]).map(r=>(
                <tr key={r.id}>
                  <td className="p-1">{r.name}</td>
                  <td className="p-1">{r.window_start || "—"} → {r.window_end || "—"}</td>
                  <td className="p-1">
                    <button className="brand-btn text-xs" onClick={()=>downloadGET(`/api/releases/notes.csv?project_id=${projectId}&id=${r.id}`, "release_notes.csv")}>Export Notes</button>
                  </td>
                </tr>
              ))}
              {!items.length && <tr><td className="p-2 text-xs text-muted-foreground" colSpan={3}>No releases yet.</td></tr>}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}


Route in client/src/App.jsx:

import Releases from "@/pages/Releases";
// …
<Route path="/projects/:projectId/releases" element={<Releases/>} />

90-second validation

Area Admins can now be assigned and will have write powers on their areas (dev-safe gate)

CRs: Intake form + Kanban board; transition buttons; CSV export; watchers receive notifications

Releases: list windows; export notes CSV (CR titles)

Workstreams: area page has Preview/Export, Open Items quick edit, smart Next Meeting

Ops: nothing breaks if tables don’t exist; endpoints return empties